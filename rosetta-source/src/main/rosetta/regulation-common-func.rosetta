namespace drr.regulation.common
version "${project.version}"

import cdm.base.*
import cdm.base.datetime.*
import cdm.base.math.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.identifier.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.position.*
import cdm.event.qualification.*
import cdm.event.workflow.*
import cdm.observable.asset.*
import cdm.product.asset.*
import cdm.product.collateral.*
import cdm.product.common.schedule.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*
import cdm.product.template.*

import drr.enrichment.upi.*
import drr.regulation.common.*
import drr.regulation.common.trade.party.* as party
import drr.regulation.common.util.*
import drr.regulation.esma.*
import drr.regulation.esma.emir.*
import drr.regulation.fca.ukemir.*
import drr.standards.iosco.cde.base.* as cdebase
import drr.standards.iosco.cde.version3.* as cde
import drr.standards.iosco.upi.* as upi
import drr.standards.iso.*

segment rationale
segment rationale_author
segment structured_provision

segment article
segment whereas
segment annex
segment table
segment section
segment field
segment paragraph
segment question
segment dataElement
segment appendix
segment footnote
segment date
segment validationRule
segment part
segment definitions

body Organisation ISO <"The International Organization for Standardization is an international standard-setting body composed of representatives from various national standards organizations. Founded on 23 February 1947, the organization promotes worldwide proprietary, industrial, and commercial standards. ">

corpus ReportingStandard "ISO 20022" ISO_20022 <"ISO 20022 is a multi part International Standard prepared by ISO Technical Committee TC68 Financial Services.">

corpus BestPractice "24Apr2024" EMIRReportingBestPractice <"The EMIR Reporting Best Practices cover 238 data points across 203 reporting fields, including both over-the-counter and exchange-traded derivatives, and were developed to improve the accuracy and efficiency of trade reporting and to reduce compliance costs. The best practices are available to all market participants to access and implement.  The EMIR Reporting Best Practices is a cross-trade association initiative developed jointly by the European Fund and Asset Management Association (EFAMA), European Venues and Intermediaries Association (EVIA), Futures Industry Association (FIA), German Investment Funds Association (BVI), Global Foreign Exchange Division (GFXD), International Swaps and Derivatives Association, Inc. (ISDA) and Investment Association (IA).">

corpus WorkingGroup "ISDA DRR Technical Execution Working Group" TechnicalExecutionGroup <"Working Group comprised of firms who determine the approach to modeling DRR and contribute to the development of DRR via test packs, coding and/or reviewing what has been modeled in line with DRR SteerCO-determined roadmap, scope & priorities.">

corpus WorkingGroup "ISDA EMIR/CFTC Digital Regulatory Reporting Peer Review" PeerReviewGroup <"Industry group which works collaboratively to mutualize representation of amended CFTC and EMIR transaction reporting requirements in Digital Regulatory Reporting (DRR) - a digitized, single standard set of open-source machine-executable code using the Common Domain Model (CDM).">

corpus WorkingGroup "ISDA EU/UK/North America Digital Regulatory Reporting Peer Review" EUUKNAPeerReviewGroup <"Industry group which works collaboratively to mutualize representation of amended EU/UK EMIR and North America transaction reporting requirements in Digital Regulatory Reporting (DRR) - a digitized, single standard set of open-source machine-executable code using the Common Domain Model (CDM).">

corpus WorkingGroup "ISDA APAC/JFSA Digital Regulatory Reporting Peer Review" APACJFSAPeerReviewGroup <"Industry group which works collaboratively to mutualize representation of amended Asia-Pacific and JFSA transaction reporting requirements in Digital Regulatory Reporting (DRR) - a digitized, single standard set of open-source machine-executable code using the Common Domain Model (CDM).">

corpus WorkingGroup "ISDA Data and Reporting EMEA Working Group" EMEADataAndReporting <"This is the primary ISDA data and reporting industry working group dedicated to issues pertaining to data and reporting in Europe, Middle East and Africa. It deals with requirements under a number of regulatory regimes, including MiFID II/MiFIR, and EMIR, amongst other national and regional regimes. The group spearheads the resolution of compliance and implementation issues through coordinated industry discussions and regulatory advocacy.">

corpus WorkingGroup "ISDA Data and Reporting Canadian Working Group" CanadianDataAndReporting <"This distribution list is responsible for addressing industry compliance and implementation issues related to trade reporting under Canadian regulatory requirements across provinces. The group has been the driving force for work such as the Multi-lateral non-dealer Canadian reporting agreement, regulatory response letters, and reporting discussions with the OSC, MSC, Quebec, BCSC and ASC.">

corpus WorkingGroup "US Compliance Working Group" USComplianceGroup <"This is an ISDA US Working Group.">

corpus WorkingGroup "ISDA Working Group" ISDAWorkingGroup <"This is an ISDA Working Group.">

// Utility Rules
func TradeStateForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableTradeState TradeState (0..1)
    set reportableTradeState:
        if reportableEvent -> reportableTrade exists
        then reportableEvent -> reportableTrade
        else reportableEvent -> originatingWorkflowStep -> businessEvent -> after only-element

func TradeForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableTrade Trade (0..1)
    set reportableTrade: TradeStateForEvent(reportableEvent) -> trade

func BeforeTradeForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableTrade Trade (0..1)
    alias businessEvent: reportableEvent -> originatingWorkflowStep -> businessEvent
    alias afterTradeUTI:
        TradeForEvent(reportableEvent) -> tradeIdentifier
            filter
                item -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then extract item -> assignedIdentifier -> identifier
            then flatten
            then only-element
    set reportableTrade:
        if Qualify_Compression(businessEvent) = True
        then BeforeTradeByUTI(reportableEvent, afterTradeUTI)
        else businessEvent -> instruction -> before -> trade only-element

func ProductForTrade: <"Extracts the product from a trade.">
    inputs:
        trade Trade (1..1)
    output:
        product Product (0..1)
    set product: trade -> tradableProduct -> product

func Counterparties: <"Extracts the two counterparties from a trade.">
    inputs:
        trade Trade (1..1)
    output:
        counterparties Party (0..2)
    add counterparties: trade -> tradableProduct -> counterparty -> partyReference

func EconomicTermsForProduct: <"Extracts the economic terms from a product.">
    inputs:
        product Product (1..1)
    output:
        economicTerms EconomicTerms (0..1)
    set economicTerms:
        if product -> contractualProduct -> economicTerms exists
        then product -> contractualProduct -> economicTerms
        else if IsProductETD(product) and product -> security -> economicTerms exists
        then product -> security -> economicTerms

func IsProductWithUnderlier:
    inputs:
        product Product (1..1)
    output:
        productWithUnderlier boolean (1..1)
    alias payout: EconomicTermsForProduct(product) -> payout
    set productWithUnderlier:
        payout -> optionPayout exists or payout -> forwardPayout exists

func UnderlierForProduct: <"Extracts the underlier product.">
    inputs:
        product Product (1..1)
    output:
        underlierProduct Product (0..1)
    set underlierProduct:
        if EconomicTermsForProduct(product) -> payout -> optionPayout exists
        then EconomicTermsForProduct(product) -> payout -> optionPayout only-element -> underlier
        else if EconomicTermsForProduct(product) -> payout -> forwardPayout exists
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> underlier

func PositionStateForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportablePositionState CounterpartyPositionState (0..1)
    set reportablePositionState:
        if reportableEvent -> reportablePosition exists
        then reportableEvent -> reportablePosition
        else reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> after only-element

func PositionForEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportablePosition CounterpartyPosition (0..1)
    set reportablePosition: PositionStateForEvent(reportableEvent) -> counterpartyPosition

func TradableProductForEvent: <"Extracts the tradableProduct from a reportableEvent.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        tradableProduct TradableProduct (0..1)
    set tradableProduct:
        if TradeForEvent(reportableEvent) exists
        then TradeForEvent(reportableEvent) -> tradableProduct
        else if PositionForEvent(reportableEvent) exists
        then PositionForEvent(reportableEvent) -> positionBase

func ProductForPosition:
    inputs:
        position CounterpartyPosition (0..1)
    output:
        product Product (0..1)
    set product: position -> positionBase -> product

func ProductForEvent: <"Extracts the product from a reportableEvent.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        product Product (0..1)
    set product:
        if TradeForEvent(reportableEvent) exists
        then ProductForTrade(TradeForEvent(reportableEvent))
        else if PositionForEvent(reportableEvent) exists
        then ProductForPosition(PositionForEvent(reportableEvent))

func SingleTradeLot: <"Extracts a single trade lot from a trade, or returns null if the trade lot attribute is not unique.">
    inputs:
        trade Trade (1..1)
    output:
        singleTradeLot TradeLot (0..1)
    set singleTradeLot: trade -> tradableProduct -> tradeLot only-element

func IsFixedInterestRate: <"Returns true if Price has priceType of InterestRate, with no spreadType specified.">
    inputs:
        price PriceSchedule (1..1)
    output:
        result boolean (1..1)
    set result:
        price -> priceType = PriceTypeEnum -> InterestRate
            and price -> arithmeticOperator is absent

func IsInterestRateSpread: <"Returns true if Price has priceType of InterestRate, and a spreadType of Spread.">
    inputs:
        price PriceSchedule (1..1)
    output:
        result boolean (1..1)
    set result:
        price -> priceType = PriceTypeEnum -> InterestRate
            and price -> arithmeticOperator = ArithmeticOperationEnum -> Add

func IsEquitySwap:
    inputs:
        tradableProduct TradableProduct (1..1)
    output:
        result boolean (1..1)
    set result: IsEquitySwapProduct(tradableProduct -> product) = True

func IsEquitySwapProduct:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_BaseProduct_EquitySwap(EconomicTermsForProduct(product)) = True

func IsCommoditySwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product)) = True
            or Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product)) = True

func IsCommoditySwaption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Swaption(EconomicTermsForProduct(product)) = True

func IsCommodityForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Forward(EconomicTermsForProduct(product)) = True

func IsCommodityFixedPriceForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsCommodityForward(product) = True
            and EconomicTermsForProduct(product) -> payout -> fixedPricePayout exists

func IsCommodityFloatingPriceForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsCommodityForward(product) = True
            and EconomicTermsForProduct(product) -> payout -> commodityPayout exists

func RateOption:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        rateOption FloatingRateOption (0..1)
    set rateOption:
        if interestRatePayout -> rateSpecification -> floatingRate exists
        then interestRatePayout -> rateSpecification -> floatingRate -> rateOption
        else if interestRatePayout -> rateSpecification -> inflationRate exists
        then interestRatePayout -> rateSpecification -> inflationRate -> rateOption

//DRR Product Qualification -> Input Type is "Product"
func IsProductOTC: <"True if the product is and OTC under contractualProduct element">
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: product -> contractualProduct exists

func IsProductETD: <"True if the product is and ETD under security element">
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        product -> security exists
            and product -> security -> securityType = SecurityTypeEnum -> ListedDerivative

func IsInflationRateBasis:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_BaseProduct_Inflation(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False
            and Qualify_SubProduct_Basis(EconomicTermsForProduct(product)) = True

func IsInterestRateCrossCurrency:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = True

func IsInterestRateCrossCurrencyBasis:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_Basis(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = True

func IsInterestRateFixedFloatSingleCurrency:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_FixedFloat(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False

func IsInterestRateFixedFixed:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_FixedFixed(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False

func IsInterestRateBasis:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_SubProduct_Basis(EconomicTermsForProduct(product)) = True
            and Qualify_BaseProduct_CrossCurrency(EconomicTermsForProduct(product)) = False

func IsInterestRateReturnSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    set result:
        if EconomicTermsForProduct(product) -> payout -> interestRatePayout count = 1
                and EconomicTermsForProduct(product) -> payout -> performancePayout count = 1
        then (EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> rateSpecification -> floatingRate exists
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> rateSpecification -> fixedRate exists
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> rateSpecification -> inflationRate exists)

func InterestRateReturnSwap:
    inputs:
        product Product (1..1)
    output:
        interestRatePayout InterestRatePayout (1..1)

    set interestRatePayout:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element

func IsGenericIRS:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: EconomicTermsForProduct(product) -> payout -> interestRatePayout count = 2

func IsOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: EconomicTermsForProduct(product) -> payout -> optionPayout exists

func IsCommoditySwapFloatFloat: //FloatFloat
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product)) = True

func IsCommoditySwapFixedFloat:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product)) = True

func IsIRSwaption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_Option_Swaption(EconomicTermsForProduct(product)) = True

func IsCapFloor:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_InterestRate_CapFloor(EconomicTermsForProduct(product)) = True

func IsFXForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> foreignExchange count = 1
            and IsProductETD(product) = False

func IsFXOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        EconomicTermsForProduct(product) -> payout -> optionPayout -> underlier -> foreignExchange exists

func IsFXPerformance:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        EconomicTermsForProduct(product) -> payout -> performancePayout -> observationTerms -> observable -> currencyPair exists

func IsFXSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product))
            or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product))

func IsFXProduct:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: IsFXForward(product) or IsFXOption(product) or IsFXSwap(product)

func IsEquity: //@TODO: should this also include equity forwards?
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_UnderlierProduct_Equity(
                    EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier
                ) = True
            or Qualify_UnderlierProduct_Equity(
                    EconomicTermsForProduct(product) -> payout -> optionPayout only-element -> underlier
                ) = True
            or Qualify_UnderlierProduct_Equity(
                    EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> underlier
                )

func IsEquityForward:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_UnderlierProduct_Equity(
                EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> underlier
            )

func IsCreditSwaption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_CreditDefaultSwaption(EconomicTermsForProduct(product)) = True

func IsCommodity:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_AssetClass_Commodity(EconomicTermsForProduct(product)) = True
            or IsSingleCommodityPayoutProduct(product) = True

func IsCreditDefaultSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_AssetClass_Credit(EconomicTermsForProduct(product)) = True

func IsCreditDefaultSwapIndex:
    inputs:
        trade Trade (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_CreditDefaultSwap_Index(EconomicTermsForProduct(ProductForTrade(trade))) = True
            or Qualify_CreditDefaultSwap_IndexTranche(
                    EconomicTermsForProduct(ProductForTrade(trade))
                ) = True

func IsCreditDefaultSwapBasket:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_CreditDefaultSwap_Basket(EconomicTermsForProduct(product)) = True

func IsPutOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsOption(product)
            and (EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Put
                or EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Receiver)

func IsCallOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        IsOption(product)
            and (EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Call
                or EconomicTermsForProduct(product) -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Payer)

func IsCap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_CapFloor(EconomicTermsForProduct(product)) = True
            and EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> capRateSchedule exists

func IsFloor:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_CapFloor(EconomicTermsForProduct(product)) = True
            and EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> floorRateSchedule exists

func IsCommodityOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_Commodity_Option(EconomicTermsForProduct(product)) = True

func IsEquityOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquityOption_PriceReturnBasicPerformance_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquityOption_PriceReturnBasicPerformance_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquityOption_PriceReturnBasicPerformance_Basket(
                    EconomicTermsForProduct(product)
                ) = True

func IsInterestRateDebtOption:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_Option_DebtOption(EconomicTermsForProduct(product)) = True

func IsVarianceSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquitySwap_ParameterReturnVariance_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVariance_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVariance_Basket(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnDispersion(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_ForeignExchange_ParameterReturnVariance(
                    EconomicTermsForProduct(product)
                ) = True

func IsVolatilitySwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquitySwap_ParameterReturnVolatility_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVolatility_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnVolatility_Basket(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_ForeignExchange_ParameterReturnVolatility(
                    EconomicTermsForProduct(product)
                ) = True

func IsDividendSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_EquitySwap_ParameterReturnDividend_SingleName(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnDividend_Index(
                    EconomicTermsForProduct(product)
                ) = True
            or Qualify_EquitySwap_ParameterReturnDividend_Basket(
                    EconomicTermsForProduct(product)
                ) = True

func IsFixedFloatZeroCouponSwap:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_InterestRate_IRSwap_FixedFloat_ZeroCoupon(EconomicTermsForProduct(product)) = True
            or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                    EconomicTermsForProduct(product)
                ) = True

func IsFixedFloatZeroCouponSwapKnownAmount:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    set result:
        IsFixedFloatZeroCouponSwap(product) = True
            and InterestRateLeg1ZeroCouponSwapKnownAmount(product) exists

//End product qualification logic
//Utility - Interest rate leg ordering
//Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0
//EMIR best practice positioned in regulation-common as it is used across global jurisdictions
func IsTotalReturnSwapDebtUnderlier:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    alias performanceUnderlier:
        product -> contractualProduct -> economicTerms -> payout -> performancePayout only-element -> underlier

    set result:
        (product -> contractualProduct -> economicTerms -> payout -> interestRatePayout, product -> contractualProduct -> economicTerms -> payout -> performancePayout) only exists
            and if performanceUnderlier exists
                then performanceUnderlier -> loan exists
                        or performanceUnderlier -> security -> securityType = SecurityTypeEnum -> Debt

func ProductOrUnderlierProduct:
    inputs:
        product Product (1..1)
    output:
        productOrUnderlierProduct Product (1..1)
    set productOrUnderlierProduct:
        if IsProductWithUnderlier(product)
        then UnderlierForProduct(product)
        else product

func InterestRateLeg1:
    [regulatoryReference ISDA EMIRReportingBestPractice
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    [regulatoryReference ISDA EMIRReportingBestPractice date "20221117"
        provision "For a single-currency ZC IR Swap with a Known Amount, DRR relies on the underlying notional being the same on each leg (i.e. notional(fixed) = notional(float))"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        if IsFixedFloatZeroCouponSwapKnownAmount(product)
        then InterestRateLeg1ZeroCouponSwapKnownAmount(product)
        else if IsInterestRateFixedFloatSingleCurrency(product)
        then InterestRateLeg1FixedFloatSingleCurrency(product)
        else if IsInterestRateCrossCurrency(product)
        then InterestRateLeg1CrossCurrency(product)
        else if IsInterestRateFixedFixed(product)
        then InterestRateLeg1FixedFixed(product)
        else if IsInterestRateBasis(product)
        then InterestRateLeg1Basis(product)
        else if IsCapFloor(product)
        then InterestRateLeg1CapFloor(product)
        else if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element
        else if IsInterestRateReturnSwap(product)
        then (if EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> contractualProduct exists
            then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> contractualProduct -> economicTerms -> payout -> interestRatePayout only-element
            else if EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> security exists
            then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> security -> economicTerms -> payout -> interestRatePayout only-element)

func InterestRateLeg2:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    set interestRateLeg2:
        if IsInterestRateFixedFloatSingleCurrency(product)
                or IsFixedFloatZeroCouponSwapKnownAmount(product)
        then InterestRateLeg2FixedFloatSingleCurrency(product)
        else if IsInterestRateCrossCurrency(product)
        then InterestRateLeg2CrossCurrency(product)
        else if IsInterestRateFixedFixed(product)
        then InterestRateLeg2FixedFixed(product)
        else if IsInterestRateBasis(product)
        then InterestRateLeg2Basis(product)
        else if IsTotalReturnSwapDebtUnderlier(product)
        then InterestRateReturnSwap(product)
        else if IsEquity(product) or IsCreditTotalReturnSwap(product)
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element

func InterestRateLeg1CrossCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg1:
        if interestRatePayouts -> priceQuantity -> quantitySchedule exists
        then interestRatePayouts
            min [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]
        else if interestRatePayouts -> priceQuantity -> quantityReference exists
        then interestRatePayouts
            min [
                item -> priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
            ]

func InterestRateLeg2CrossCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg2:
        if interestRatePayouts -> priceQuantity -> quantitySchedule exists
        then interestRatePayouts
            max [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]
        else if interestRatePayouts -> priceQuantity -> quantityReference exists
        then interestRatePayouts
            max [
                item -> priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
            ]

func InterestRateLeg1FixedFloatSingleCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
            filter item -> rateSpecification -> fixedRate exists
            then only-element

func InterestRateLeg2FixedFloatSingleCurrency:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    set interestRateLeg2:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
            filter
                item -> rateSpecification -> floatingRate exists
                    or item -> rateSpecification -> inflationRate exists
            then only-element

func InterestRateLeg1ZeroCouponSwapKnownAmount:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
            filter item -> priceQuantity exists and item -> rateSpecification is absent
            then only-element

func InterestRateLeg1FixedFixed:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg1:
        if interestRatePayouts -> rateSpecification -> fixedRate distinct count = 1
        then interestRatePayouts min [ CalculationPeriodToDays(item) ]
        else if interestRatePayouts -> rateSpecification -> fixedRate distinct count > 1
        then interestRatePayouts
            max [ item -> rateSpecification -> fixedRate -> rateSchedule -> price -> value ]

func InterestRateLeg2FixedFixed:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg2:
        if interestRatePayouts -> rateSpecification -> fixedRate distinct count = 1
        then interestRatePayouts max [ CalculationPeriodToDays(item) ]
        else if interestRatePayouts -> rateSpecification -> fixedRate distinct count > 1
        then interestRatePayouts
            min [ item -> rateSpecification -> fixedRate -> rateSchedule -> price -> value ]

func InterestRateLeg1CapFloor:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    set interestRateLeg1:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element

func InterestRateLeg1Basis:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg1 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg1:
        if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
                distinct
                count > 1
        then interestRatePayouts
            max [
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
            ]
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule
                distinct
                count = 1
        then (interestRatePayouts
            filter
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value exists
            then only-element)
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule is absent
        then interestRatePayouts min [ ResetFrequencyPeriodToDays(item) ]

func InterestRateLeg2Basis:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        interestRateLeg2 InterestRatePayout (0..1)
    alias interestRatePayouts:
        EconomicTermsForProduct(product) -> payout -> interestRatePayout
    set interestRateLeg2:
        if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
                distinct
                count > 1
        then interestRatePayouts
            min [
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value
            ]
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule
                distinct
                count = 1
        then (interestRatePayouts
            filter
                item -> rateSpecification -> floatingRate -> spreadSchedule -> price -> value is absent
            then only-element)
        else if interestRatePayouts -> rateSpecification -> floatingRate -> spreadSchedule is absent
        then interestRatePayouts max [ ResetFrequencyPeriodToDays(item) ]

func ResetFrequencyPeriodToDays:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        result int (1..1)
    alias resetDates: interestRatePayout -> resetDates
    set result:
        PeriodExtendedCalculation(
                resetDates -> resetFrequency -> period,
                resetDates -> resetFrequency -> periodMultiplier,
                resetDates -> calculationPeriodDatesReference -> effectiveDate -> adjustableDate -> unadjustedDate,
                resetDates -> calculationPeriodDatesReference -> terminationDate -> adjustableDate -> unadjustedDate
            )

func CalculationPeriodToDays:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        result int (1..1)
    alias calculationPeriodDates: interestRatePayout -> calculationPeriodDates
    set result:
        PeriodExtendedCalculation(
                calculationPeriodDates -> calculationPeriodFrequency -> period,
                calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier,
                calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
                calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate
            )

func CalculationPeriodToDaysCommodities:
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        result int (1..1)
    alias calculationPeriodDates: commodityPayout -> calculationPeriodDates
    set result:
        PeriodExtendedCalculation(
                calculationPeriodDates -> calculationPeriodFrequency -> period,
                calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier,
                calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate,
                calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate
            )

func PeriodCalculation:
    inputs:
        period PeriodEnum (1..1)
        periodMultiplier int (1..1)
    output:
        result int (1..1)

    set result:
        if period = PeriodEnum -> D
        then periodMultiplier
        else if period = PeriodEnum -> W
        then periodMultiplier * 7
        else if period = PeriodEnum -> M
        then periodMultiplier * 30
        else if period = PeriodEnum -> Y
        then periodMultiplier * 365

func PeriodExtendedCalculation:
    inputs:
        periodExtended PeriodExtendedEnum (1..1)
        periodMultiplier int (1..1)
        effectiveDate date (1..1)
        terminationDate date (1..1)
    output:
        result int (1..1)
    alias period: periodExtended to-enum PeriodEnum
    set result:
        if period exists
        then PeriodCalculation(period, periodMultiplier)
        else if periodExtended = PeriodExtendedEnum -> T
                or periodExtended = PeriodExtendedEnum -> C
        then periodMultiplier * DateDifference(effectiveDate, terminationDate)

func GetCommodityKey:
    [codeImplementation]
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        key string (0..1)

func CommodityLeg1:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        commodityLeg1 CommodityPayout (0..1)
    alias commodityPayouts: EconomicTermsForProduct(product) -> payout -> commodityPayout
    set commodityLeg1:
        if IsCommoditySwapFloatFloat(product)
        then CommodityCommodityLeg1(commodityPayouts) // moved to separate func due to nested if/else code gen issue
        else if IsCommodityFloatingPriceForward(product)
        then commodityPayouts only-element

func CommodityCommodityLeg1:
    inputs:
        commodityPayouts CommodityPayout (0..*)
    output:
        commodityLeg1 CommodityPayout (0..1)

    set commodityLeg1:
        if (commodityPayouts
            extract GetCommodityKey(item)
            then exists)
        then commodityPayouts min [ GetCommodityKey(item) ]
        else if commodityPayouts -> priceQuantity -> resolvedQuantity -> value
                distinct
                count = 1
        then commodityPayouts min [ CalculationPeriodToDaysCommodities(item) ]
        else commodityPayouts max [ item -> priceQuantity -> quantitySchedule -> value ]

func CommodityLeg2:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        commodityLeg2 CommodityPayout (0..1)
    alias commodityPayouts: EconomicTermsForProduct(product) -> payout -> commodityPayout
    set commodityLeg2:
        if IsCommoditySwapFloatFloat(product)
        then CommodityCommodityLeg2(commodityPayouts) // moved to separate func due to nested if/else code gen issue
        else if IsCommoditySwapFixedFloat(product)
        then commodityPayouts only-element

func CommodityCommodityLeg2:
    inputs:
        commodityPayouts CommodityPayout (0..*)
    output:
        commodityLeg2 CommodityPayout (0..1)
    set commodityLeg2:
        if (commodityPayouts
            extract GetCommodityKey(item)
            then exists)
        then commodityPayouts max [ GetCommodityKey(item) ]
        else if commodityPayouts -> priceQuantity -> resolvedQuantity -> value
                distinct
                count = 1
        then commodityPayouts max [ CalculationPeriodToDaysCommodities(item) ]
        else commodityPayouts min [ item -> priceQuantity -> quantitySchedule -> value ]

func FixedPriceLeg1:
    inputs:
        product Product (1..1)
    output:
        fixedPrice FixedPricePayout (0..1)

    set fixedPrice:
        if IsCommoditySwapFixedFloat(product) or IsCommodityFixedPriceForward(product)
        then EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element

func FXLeg1:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        fxLeg1 Cashflow (0..1)
    set fxLeg1:
        if IsFXForward(product) or IsFXOption(product)
        then [UnderlierForProduct(product) -> foreignExchange -> exchangedCurrency1, UnderlierForProduct(
                    product
                ) -> foreignExchange -> exchangedCurrency2]
            min [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func FXLeg2:
    [regulatoryReference ISDA EMIRReportingBestPractice table "ESMA reporting best practices matrix March 2020"
        provision "Best Practice For Leg 1 / Leg 2 Determination and population of Counterparty Side for EMIR RTS 2.0"]
    inputs:
        product Product (1..1)
    output:
        fxLeg2 Cashflow (0..1)
    set fxLeg2:
        if IsFXForward(product) or IsFXOption(product)
        then [UnderlierForProduct(product) -> foreignExchange -> exchangedCurrency1, UnderlierForProduct(
                    product
                ) -> foreignExchange -> exchangedCurrency2]
            max [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func FXNearLeg:
    inputs:
        product Product (1..1)
    output:
        nearLegPayout ForwardPayout (0..1)
    alias forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout
    set nearLegPayout:
        // value date
        if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> settlementTerms -> settlementDate -> valueDate exists
        then forwardPayout min [ item -> settlementTerms -> settlementDate -> valueDate ]
        // adjustable or relative date
        else if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then forwardPayout
            min [
                AdjustableOrAdjustedOrRelativeDateResolution(
                        item -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
                    )
            ]

func FXFarLeg:
    inputs:
        product Product (1..1)
    output:
        farLegPayout ForwardPayout (0..1)
    alias forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout
    set farLegPayout:
        // value date
        if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> settlementTerms -> settlementDate -> valueDate exists
        then forwardPayout max [ item -> settlementTerms -> settlementDate -> valueDate ]
        // adjustable or relative date
        else if (Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product)) or Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product)))
                and forwardPayout -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate exists
        then forwardPayout
            max [
                AdjustableOrAdjustedOrRelativeDateResolution(
                        item -> underlier -> foreignExchange -> exchangedCurrency1 -> settlementTerms -> settlementDate -> adjustableOrRelativeDate
                    )
            ]

func FXSwapLeg1:
    inputs:
        product Product (1..1)
    output:
        fxLeg1 Cashflow (0..1)
    alias farLeg: FXFarLeg(product)
    set fxLeg1:
        [farLeg -> underlier -> foreignExchange -> exchangedCurrency1, farLeg -> underlier -> foreignExchange -> exchangedCurrency2]
            min [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func FXSwapLeg2:
    inputs:
        product Product (1..1)
    output:
        fxLeg2 Cashflow (0..1)
    alias farLeg: FXFarLeg(product)
    set fxLeg2:
        [farLeg -> underlier -> foreignExchange -> exchangedCurrency1, farLeg -> underlier -> foreignExchange -> exchangedCurrency2]
            max [ item -> priceQuantity -> quantitySchedule -> unit -> currency ]

func CommodityQuantity: <"Commodity Notional Quantity">
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        quantity number (0..1)
    set quantity:
        if commodityPayout -> priceQuantity -> quantitySchedule -> value exists
        then commodityPayout -> priceQuantity -> quantitySchedule -> value

func CommodityFixedPriceQuantity:
    inputs:
        tradeLot TradeLot (1..1)
    output:
        fixedLegPriceQuantity PriceQuantity (0..1)
    set fixedLegPriceQuantity:
        tradeLot -> priceQuantity
            filter item -> observable is absent
            then only-element

func QuantityFrequencyOrCalculationPeriod:
    inputs:
        calculationPeriodDates CalculationPeriodDates (1..1)
        priceQuantity PriceQuantity (1..1)
    output:
        frequency Frequency (0..1)
    alias quantity:
        priceQuantity -> quantity
            filter item -> value exists or item -> datedValue -> value distinct count = 1
    set frequency:
        if quantity -> frequency -> period only-element <> PeriodExtendedEnum -> C
        then quantity -> frequency only-element
        else if quantity -> frequency -> period only-element = PeriodExtendedEnum -> C
        then calculationPeriodDates -> calculationPeriodFrequency

func FrequencyPeriod:
    inputs:
        priceQuantity PriceQuantity (1..1)
        frequency Frequency (0..1)
    output:
        period FrequencyPeriodEnum (0..1)
    alias quantity:
        priceQuantity -> quantity
            filter
                item -> frequency exists
                    and (item -> value exists or item -> datedValue -> value distinct count = 1)
    set period:
        if frequency is absent and quantity exists
        then ADHO
        else cdebase.payment.MapCDEFrequencyPeriod(frequency -> period)

func FrequencyPeriodMultiplier:
    inputs:
        frequency Frequency (1..1)
    output:
        periodMultiplier int (0..1)
    set periodMultiplier: frequency -> periodMultiplier

func CommodityFrequencyMultiplier: <"Commodity Quantity Frequency Multiplier">
    inputs:
        commodityPayout CommodityPayout (1..1)
    output:
        periodMultiplier int (0..1)
    set periodMultiplier:
        if commodityPayout -> priceQuantity -> quantitySchedule exists
        then commodityPayout -> priceQuantity -> quantitySchedule -> frequency -> periodMultiplier

func PartyLei: <"Returns a single Party LEI from a list of party identifiers">
    inputs:
        partyIdentifier PartyIdentifier (1..*)
    output:
        partyLei string (0..1)
    set partyLei:
        partyIdentifier
            filter identifierType = PartyIdentifierTypeEnum -> LEI
            then identifier distinct only-element

func PartyLeiAndPersonByRoles: <"Returns a concatenated Party LEI and Person Id, or a Party LEI, from a PartyInformation.">
    inputs:
        party Party (0..1)
        reportingParty Party (0..1)
    output:
        partyPersonLei string (0..1)

    alias partyLei:
        if party -> partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI
        then PartyLei(party -> partyId)

    alias partyPersonId: // Returns a Person Id from a Party
        party
            filter [
                personRole -> role // role is multi-cardinality
                    extract r [ PartyIdentifierNaturalPersonRoles contains r ]
                any = True
            ]
            then extract person -> personId -> identifier
            then only-element

    alias reportingPartyLei:
        if reportingParty -> partyId -> identifierType any = PartyIdentifierTypeEnum -> LEI
        then PartyLei(reportingParty -> partyId)

    set partyPersonLei:
        if partyPersonId exists
        then (if reportingPartyLei exists then reportingPartyLei + partyPersonId else partyLei + partyPersonId)
        else partyLei

func PartyIdentifierFormat: <"Returns a Person Id from a Party.">
    inputs:
        party Party (1..1)
    output:
        partyIdentifierFormat PartyIdentifierFormatEnum (1..1)

    alias personId:
        party
            filter [
                personRole -> role // role is multi-cardinality
                    extract r [ PartyIdentifierNaturalPersonRoles contains r ]
                any = True
            ]
            then extract person -> personId -> identifier
            then only-element
    set partyIdentifierFormat:
        if personId exists
        then PartyIdentifierFormatEnum -> LeiAndPerson
        else PartyIdentifierFormatEnum -> Lei

func PartyIdentifierType: <"Returns a Person Identifier Type from a Party.">
    inputs:
        party Party (1..1)
    output:
        partyIdentifierFormat string (1..*)

    alias personId:
        party
            filter [
                personRole -> role // role is multi-cardinality
                    extract r [ PartyIdentifierNaturalPersonRoles contains r ]
                any = True
            ]
            then extract person -> personId
    add partyIdentifierFormat:
        if personId -> identifierType any = NPID
        then PersonIdentifierTypeEnum -> NPID to-string
        else if personId -> identifierType any = PLID
        then PersonIdentifierTypeEnum -> PLID to-string
        else PartyIdentifierTypeEnum -> LEI to-string

func PartyIdentifierNaturalPersonRoles:
    output:
        roles NaturalPersonRoleEnum (0..*)
    add roles: [NaturalPersonRoleEnum -> Buyer, NaturalPersonRoleEnum -> Seller]

func FilterPartyInformationBySupervisoryBody:
    inputs:
        partyInformation PartyInformation (1..*)
        jurisdiction SupervisoryBodyEnum (1..1)
    output:
        filteredPartyInformation PartyInformation (1..*)
    add filteredPartyInformation:
        partyInformation
            filter item -> regimeInformation -> supervisoryBody any = jurisdiction

func ExtractOtherPaymentPayer:
    inputs:
        transferState TransferState (0..1)
        transactionReportInstruction TransactionReportInstruction (0..1)
    output:
        partyPersonLei string (0..1)
    set partyPersonLei:
        PartyLeiAndPersonByRoles(
                transferState -> transfer -> payerReceiver -> payerPartyReference,
                transactionReportInstruction -> reportingSide -> reportingParty
            )

func ExtractOtherPaymentReceiver:
    inputs:
        transferState TransferState (0..1)
        transactionReportInstruction TransactionReportInstruction (0..1)
    output:
        partyPersonLei string (0..1)
    set partyPersonLei:
        PartyLeiAndPersonByRoles(
                transferState -> transfer -> payerReceiver -> receiverPartyReference,
                transactionReportInstruction -> reportingSide -> reportingParty
            )

func ExtractPartyResponsibleForReporting: <"Extracts the reporting party for a supervisory body (e.g. CFTC).">
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        partyResponsibleForReporting Party (0..1)

    set partyResponsibleForReporting:
        if reportingSide -> partyResponsibleForReporting exists
        then reportingSide -> partyResponsibleForReporting
        else reportingSide -> reportingParty

func ExtractPartyResponsibleForReportingIdentifier:
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        identifier string (0..1)

    set identifier:
        ExtractPartyResponsibleForReporting(reportingSide) extract PartyLei(partyId)

func ExtractReportSubmittingParty: <"Extracts the reporting party for a supervisory body (e.g. CFTC).">
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        reportSubmittingParty Party (0..1)

    alias reportSubmittingPartyFromReportingSide: reportingSide -> reportSubmittingParty

    set reportSubmittingParty:
        if reportingSide -> reportSubmittingParty exists
        then reportingSide -> reportSubmittingParty
        else reportingSide -> reportingParty

func ExtractReportSubmittingPartyIdentifier:
    inputs:
        reportingSide ReportingSide (1..1)
    output:
        identifier string (0..1)

    set identifier: ExtractReportSubmittingParty(reportingSide) extract PartyLei(partyId)

func ExtractPartyFromRelatedPartyByRole:
    inputs:
        relatedParties RelatedParty (0..*)
        partyRole PartyRoleEnum (1..1)
    output:
        party Party (0..1)

    set party:
        FilterRelatedPartyByRole(relatedParties, partyRole) -> partyReference
            distinct
            only-element

func SettlementTermsLeg1:
    inputs:
        product Product (1..1)
    output:
        settlementTerms SettlementTerms (0..1)

    alias economicTerms: EconomicTermsForProduct(product)

    set settlementTerms:
        // Interest Rates + Credit
        if InterestRateLeg1(product) -> settlementTerms exists
        then InterestRateLeg1(product) -> settlementTerms // to be adapted to take economicTerms if possible
            // Credit
        else if economicTerms -> payout -> creditDefaultPayout -> settlementTerms exists
        then economicTerms -> payout -> creditDefaultPayout -> settlementTerms
        // Equities
        else if economicTerms -> payout -> performancePayout -> settlementTerms exists
        then economicTerms -> payout -> performancePayout only-element -> settlementTerms
        // FX Swaps
        else if IsFXSwap(product)
        then FXFarLeg(product) -> settlementTerms
        // Commodities   //functions to be adapted to take economicTerms if possible
        else if IsCommoditySwapFloatFloat(product)
        then CommodityLeg1(product) -> settlementTerms
        else if IsSingleCommodityPayoutProduct(product)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> settlementTerms
        else if IsCommoditySwapFixedFloat(product)
        then FixedPriceLeg1(product) -> settlementTerms
        else if IsCommodityFixedPriceForward(product) = True
        then EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element -> settlementTerms
        else if IsCommodityFloatingPriceForward(product) = True
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> settlementTerms
        // Options
        else if economicTerms -> payout -> optionPayout -> settlementTerms exists
        then economicTerms -> payout -> optionPayout only-element -> settlementTerms
        // Forwards
        else if economicTerms -> payout -> forwardPayout only-element -> settlementTerms exists
        then economicTerms -> payout -> forwardPayout only-element -> settlementTerms

func SettlementTermsLeg2:
    inputs:
        product Product (1..1)
    output:
        settlementTerms SettlementTerms (0..1)
    set settlementTerms:
        // Interest Rates + Equity
        if InterestRateLeg2(product) -> settlementTerms exists
        then InterestRateLeg2(product) -> settlementTerms
        // FX Swaps
        else if IsFXSwap(product)
        then FXNearLeg(product) -> settlementTerms
        // Commodities
        else if IsCommoditySwap(product)
        then CommodityLeg2(product) -> settlementTerms
        else if IsCommodityForward(product)
                and (EconomicTermsForProduct(product) -> payout -> forwardPayout only-element exists) = False
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> settlementTerms
        // Equities
        else if IsEquitySwapProduct(product)
                and EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> settlementTerms exists
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout only-element -> settlementTerms
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> settlementTerms exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> settlementTerms

func IsCleared: <"Qualifies a transaction that has been cleared by a CCP.">
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        result boolean (1..1)
    set result:
        originatingWorkflowStep -> workflowState -> workflowStatus = WorkflowStatusEnum -> Cleared
            or (( // Trade already cleared in a previous WorkflowStep
                originatingWorkflowStep -> timestamp -> qualification any = EventTimestampQualificationEnum -> clearingDateTime
                        // There's an ongoing clearing process - CDM-native
                    or Qualify_ClearedTrade(originatingWorkflowStep -> businessEvent) = True
                        // There's an ongoing clearing process - ingested event
                    or originatingWorkflowStep -> businessEvent -> intent = Clearing)
                        // The Trade is not intended to clear (alpha TERM discarded)
                and IntendedToClear(originatingWorkflowStep) = False)

func IsCompressed:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_Compression(originatingWorkflowStep -> businessEvent) = True
            or originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> Compression

func IsPortfolioRebalancing:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_PortfolioRebalancing(originatingWorkflowStep -> businessEvent) = True
            or originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> PortfolioRebalancing

func IsPriceMonetary:
    inputs:
        price PriceSchedule (1..1)
    output:
        result boolean (1..1)
    set result:
        price -> unit -> currency exists
            and (price -> perUnitOf -> currency is absent // Hence not a rate
                or price -> perUnitOf -> currency <> price -> unit -> currency // Hence a currency Pair
                )

func IsOtherPayment:
    inputs:
        transferState TransferState (1..1)
    output:
        result boolean (1..1)
    alias transferExpression: transferState -> transfer -> transferExpression
    set result:
        transferExpression -> priceTransfer = FeeTypeEnum -> Upfront
            or transferExpression -> priceTransfer = FeeTypeEnum -> Termination
            or transferExpression -> priceTransfer = FeeTypeEnum -> PartialTermination
            or transferExpression -> scheduledTransfer -> transferType = ScheduledTransferEnum -> PrincipalPayment

func MaxTerminationDate:
    inputs:
        date1 AdjustableDate (0..1)
        date2 AdjustableDate (0..1)
    output:
        date date (0..1)

    set date:
        if AdjustableDateResolution(date1) > AdjustableDateResolution(date2)
        then AdjustableDateResolution(date1)
        else AdjustableDateResolution(date2)

func CapacityUnitToISO20022UnitOfMeasure:
    inputs:
        capacityUnit CapacityUnitEnum (1..1)
    output:
        result string (1..1)
    set result:
        if capacityUnit = CapacityUnitEnum -> ALW
        then "ALOW"
        else if capacityUnit = CapacityUnitEnum -> BBL
        then "BARL"
        else if capacityUnit = CapacityUnitEnum -> BCF
        then "BCUF"
        else if capacityUnit = CapacityUnitEnum -> BDFT
        then "BDFT"
        else if capacityUnit = CapacityUnitEnum -> GBBSH
        then "BUSL"
        else if capacityUnit = CapacityUnitEnum -> GBBTU
        then "BRTU"
        else if capacityUnit = CapacityUnitEnum -> CBM
        then "CBME"
        else if capacityUnit = CapacityUnitEnum -> CER
        then "CEER"
        else if capacityUnit = CapacityUnitEnum -> CRT
        then "CLRT"
        else if capacityUnit = CapacityUnitEnum -> DAG
        then empty
        else if capacityUnit = CapacityUnitEnum -> DAY
        then "DAYS"
        else if capacityUnit = CapacityUnitEnum -> DMTU
        then "DMET"
        else if capacityUnit = CapacityUnitEnum -> ENVCRD
        then "ENVC"
        else if capacityUnit = CapacityUnitEnum -> ENVOFST
        then "ENVO"
        else if capacityUnit = CapacityUnitEnum -> FEU
        then empty
        else if capacityUnit = CapacityUnitEnum -> G
        then "GRAM"
        else if capacityUnit = CapacityUnitEnum -> GBCWT
        then "HUWG"
        else if capacityUnit = CapacityUnitEnum -> GBGAL
        then "GBGA"
        else if capacityUnit = CapacityUnitEnum -> GBT
        then "GBTN"
        else if capacityUnit = CapacityUnitEnum -> GJ
        then "GGJL"
        else if capacityUnit = CapacityUnitEnum -> GW
        then empty
        else if capacityUnit = CapacityUnitEnum -> GWH
        then "GWHO"
        else if capacityUnit = CapacityUnitEnum -> HL
        then empty
        else if capacityUnit = CapacityUnitEnum -> J
        then "JOUL"
        else if capacityUnit = CapacityUnitEnum -> KG
        then "KILO"
        else if capacityUnit = CapacityUnitEnum -> KL
        then empty
        else if capacityUnit = CapacityUnitEnum -> KW
        then empty
        else if capacityUnit = CapacityUnitEnum -> KWD
        then "KWDC"
        else if capacityUnit = CapacityUnitEnum -> KWH
        then "KWHO"
        else if capacityUnit = CapacityUnitEnum -> KWH
        then "KWHC"
        else if capacityUnit = CapacityUnitEnum -> KWMIN
        then "KMOC"
        else if capacityUnit = CapacityUnitEnum -> KWM
        then "KWMC"
        else if capacityUnit = CapacityUnitEnum -> KWY
        then "KWYC"
        else if capacityUnit = CapacityUnitEnum -> L
        then "LITR"
        else if capacityUnit = CapacityUnitEnum -> LB
        then "PUND"
        else if capacityUnit = CapacityUnitEnum -> MB
        then empty
        else if capacityUnit = CapacityUnitEnum -> MBF
        then empty
        else if capacityUnit = CapacityUnitEnum -> MJ
        then empty
        else if capacityUnit = CapacityUnitEnum -> MMBF
        then empty
        else if capacityUnit = CapacityUnitEnum -> MMBBL
        then "MIBA"
        else if capacityUnit = CapacityUnitEnum -> USMMBTU
        then "MBTU"
        else if capacityUnit = CapacityUnitEnum -> MSF
        then empty
        else if capacityUnit = CapacityUnitEnum -> MT
        then "TONE"
        else if capacityUnit = CapacityUnitEnum -> MW
        then empty
        else if capacityUnit = CapacityUnitEnum -> MWD
        then "MWDC"
        else if capacityUnit = CapacityUnitEnum -> MWH
        then "MWHO"
        else if capacityUnit = CapacityUnitEnum -> MWH
        then "MWHC"
        else if capacityUnit = CapacityUnitEnum -> MWM
        then "MMOC"
        else if capacityUnit = CapacityUnitEnum -> MWMIN
        then "MWMC"
        else if capacityUnit = CapacityUnitEnum -> MWY
        then "MWYC"
        else if capacityUnit = CapacityUnitEnum -> OZT
        then "OZTR"
        else if capacityUnit = CapacityUnitEnum -> TEU
        then empty
        else if capacityUnit = CapacityUnitEnum -> USTHM
        then "THMS"
        else if capacityUnit = CapacityUnitEnum -> USCWT
        then "UCWT"
        else if capacityUnit = CapacityUnitEnum -> USGAL
        then "USGA"
        else if capacityUnit = CapacityUnitEnum -> UST
        then "USTN"

func WeatherUnitToISO20022UnitOfMeasure:
    inputs:
        weatherUnit WeatherUnitEnum (1..1)
    output:
        result string (1..1)
    set result:
        if weatherUnit = WeatherUnitEnum -> CDD
        then "CDDA"
        else if weatherUnit = WeatherUnitEnum -> CPD
        then "CPDA"
        else if weatherUnit = WeatherUnitEnum -> HDD
        then "HDDA"

func FinancialUnitToISO20022UnitOfMeasure:
    inputs:
        financialUnit FinancialUnitEnum (1..1)
    output:
        result string (1..1)
    set result:
        if financialUnit = FinancialUnitEnum -> Contract
        then empty
        else if financialUnit = FinancialUnitEnum -> ContractualProduct
        then "ACCY"
        else if financialUnit = FinancialUnitEnum -> IndexUnit
        then "IPNT"
        else if financialUnit = FinancialUnitEnum -> LogNormalVolatility
        then empty
        else if financialUnit = FinancialUnitEnum -> Share
        then "SHAS"
        else if financialUnit = FinancialUnitEnum -> ValuePerDay
        then empty
        else if financialUnit = FinancialUnitEnum -> ValuePerPercent
        then empty

func ExtractTradeCounterparty:
    inputs:
        reportableEvent ReportableEvent (1..1)
        role CounterpartyRoleEnum (1..1)
    output:
        counterparty Counterparty (0..1)

    alias counterparties: TradeForEvent(reportableEvent) -> tradableProduct -> counterparty

    set counterparty: ExtractCounterpartyByRole(counterparties, role)

func ClearingExceptionsAndExemptions:
    inputs:
        clearingExceptionReason ClearingExceptionReasonEnum (1..1)
    output:
        result ClearingExceptionsAndExemptionsEnum (1..1)
    set result:
        if clearingExceptionReason = ClearingExceptionReasonEnum -> End_User
        then ENDU
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> Inter_Affiliate
        then AFFL
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> SmallBank
        then SMBK
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> Cooperative
        then COOP
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> NoActionLetter
        then NOAL
        else if clearingExceptionReason = ClearingExceptionReasonEnum -> Exception
        then OTHR

// TH Revision: should values AgentAffiliate and TreasuryAffiliate be reported as a) OTHR, b) AFFL, c) Not reported.
// In case a) line
// if clearingExceptionReason = ClearingExceptionReasonEnum -> Exception then "OTHR"
// should be replaced by:
// if clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> AgentAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> TreasuryAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> Exception then "OTHR"
// In case b) line
// if clearingExceptionReason = ClearingExceptionReasonEnum -> InterAffiliate then "AFFL" else
// should be replaced by:
// if clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> InterAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> TreasuryAffiliate or
// clearingException -> clearingExceptionReason = ClearingExceptionReasonEnum -> Exception then "AFFL" else
// In case c), nothing needs to be changed.
func IsActionTypeTERM:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeTerm boolean (1..1)
    set isActionTypeTerm:
        if (QuantityDecreasedToZero(
                        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before,
                        reportableEvent -> originatingWorkflowStep -> businessEvent -> after
                    ) = True
                or (TradeStateForEvent(reportableEvent) -> state -> positionState = PositionStatusEnum -> Closed)
                or (reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> after -> state -> positionState only-element = PositionStatusEnum -> Closed) // TODO to be revisted once counterpartyPositionBusinessEvent supports more than one after state
                or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EarlyTerminationProvision)
        then True
        else False

func IntendedToClear:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
    output:
        isIntendedToClear boolean (1..1)
    set isIntendedToClear:
        if originatingWorkflowStep -> nextEvent -> intent = EventIntentEnum -> Clearing
        then True
        else False

func IsActionTypeMODI:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result boolean (1..1)

    alias primitiveInstruction:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> primitiveInstruction
    alias beforeTradeState:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before only-element
    alias afterTradeStateOpen:
        FilterOpenTradeStates(TradeStateForEvent(reportableEvent)) only-element
    alias prevUTI:
        BeforeTradeForEvent(reportableEvent) -> tradeIdentifier
            filter
                item -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then only-element
            then extract item -> assignedIdentifier -> identifier
    alias currUTI:
        TradeForEvent(reportableEvent) -> tradeIdentifier
            filter
                item -> identifierType = TradeIdentifierTypeEnum -> UniqueTransactionIdentifier
            then only-element
            then extract item -> assignedIdentifier -> identifier
    alias product: ProductForTrade(TradeForEvent(reportableEvent))

    set result:
        if IsProductETD(product) = False
                and reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent is absent
        then if (reportableEvent -> originatingWorkflowStep -> action <> ActionEnum -> Correct
                    and reportableEvent -> reportableInformation -> reportableAction <> ReportableActionEnum -> Error
                    and IsActionTypeTERM(reportableEvent) = False)
            then if reportableEvent -> reportableInformation -> reportableAction = ReportableActionEnum -> Modification
                then True
                else if reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> ContractTermsAmendment
                then True
                else if (Qualify_Exercise(
                                reportableEvent -> originatingWorkflowStep -> businessEvent
                            ) = True
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> OptionExercise
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> OptionalExtension
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> OptionalCancellation
                        or Qualify_CorporateActionDetermined(
                                reportableEvent -> originatingWorkflowStep -> businessEvent
                            )
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> CorporateActionAdjustment
                        or Qualify_CreditEventDetermined(
                                reportableEvent -> originatingWorkflowStep -> businessEvent
                            )
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> CreditEvent
                        or QuantityDecreased(beforeTradeState, afterTradeStateOpen) = True
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> Decrease)
                then (if prevUTI = currUTI then True else False)
                else if Qualify_Increase(
                            reportableEvent -> originatingWorkflowStep -> businessEvent
                        )
                        or reportableEvent -> originatingWorkflowStep -> businessEvent -> intent = EventIntentEnum -> Increase
                then True
                else if primitiveInstruction -> termsChange exists
                then True
                else if reportableEvent -> reportableInformation -> reportableAction = ReportableActionEnum -> Update
                then True
                else False
            else False
        else False

func IsActionTypeNEWT:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeNewt boolean (1..1)
    set isActionTypeNewt:
        IsActionTypeTERM(reportableEvent) = False
            and IsActionTypeMODI(reportableEvent) = False
            and IsActionTypePositionMODI(reportableEvent) = False
            and IsActionTypePOSC(reportableEvent) = False
            and (reportableEvent -> originatingWorkflowStep -> action = ActionEnum -> New
                or reportableEvent -> originatingWorkflowStep -> action is absent)

func IsActionTypeCORR:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeCorr boolean (1..1)

    alias workflowStepAction: reportableEvent -> originatingWorkflowStep -> action
    alias reportingAction: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypeCorr:
        (reportingAction exists and reportingAction = ReportableActionEnum -> Correct)
            or (workflowStepAction = ActionEnum -> Correct)

func IsActionTypeVALU:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeValu boolean (1..1)
    set isActionTypeValu:
        Qualify_ValuationUpdate(reportableEvent -> originatingWorkflowStep -> businessEvent)

func IsActionTypeEROR:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeEror boolean (1..1)

    alias workflowStepAction: reportableEvent -> originatingWorkflowStep -> action
    alias reportingAction: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypeEror:
        (reportingAction exists and reportingAction = ReportableActionEnum -> Error)

func IsActionTypeREVI:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypeRevi boolean (1..1)
    alias action: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypeRevi: action exists and action = ReportableActionEnum -> Revive

func IsEventTypeUPDT: <"The qualification of the Update event as an upgrade of an outstanding transaction performed in order to ensure its conformity with the amended reporting requirements.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isEventTypeUpdt boolean (1..1)
    alias event: reportableEvent -> reportableInformation -> reportableAction
    set isEventTypeUpdt: event exists and event = ReportableActionEnum -> Update

func IsActionTypePRTO: <"The qualification of the Transfer Out action that transfers swap transaction from one SDR to another SOR (change of swap data repository).">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypePrto boolean (1..1)
    alias action: reportableEvent -> reportableInformation -> reportableAction
    set isActionTypePrto: action exists and action = ReportableActionEnum -> TransferOut

func IsEventTypePTNG: <"The qualification of the Transfer In event by which a swap is transferred to another SDR that has the effect of the closing of the suap transaction at one 50 or opening of the same swap transaction using the same UTI/USI in a different SDR (new).">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isEventTypePtng boolean (1..1)
    alias event: reportableEvent -> reportableInformation -> reportableAction
    set isEventTypePtng: event exists and event = ReportableActionEnum -> TransferIn

func IsActionTypePOSC:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypePosc boolean (1..1)
    alias product: ProductForTrade(TradeForEvent(reportableEvent))
    set isActionTypePosc:
        reportableEvent -> originatingWorkflowStep -> action = ActionEnum -> New
            and reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent is absent
            and IsProductETD(product)

func IsActionTypePositionMODI:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isActionTypePositionModi boolean (1..1)
    alias product: ProductForTrade(TradeForEvent(reportableEvent))
    alias openPositionDate:
        reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> after -> counterpartyPosition -> openDateTime -> date
            distinct
            only-element // opentDateTime always the same
    alias eventDate:
        reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent -> eventDate
    set isActionTypePositionModi:
        if reportableEvent -> originatingWorkflowStep -> action = ActionEnum -> New
                and reportableEvent -> originatingWorkflowStep -> counterpartyPositionBusinessEvent exists
                and (openPositionDate < eventDate)
                and IsActionTypeTERM(reportableEvent) = False
        then True
        else False

func IsAllowableAction:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        isAllowableAction boolean (1..1)

    set isAllowableAction:
        IsActionTypeNEWT(reportableEvent)
            or IsActionTypeMODI(reportableEvent)
            or IsActionTypePositionMODI(reportableEvent)
            or IsActionTypeCORR(reportableEvent)
            or IsActionTypeREVI(reportableEvent)
            or IsActionTypePOSC(reportableEvent)

func IsVRAllowedForActionType:
    inputs:
        actionTypefromTrade ActionTypeEnum (1..1)
    output:
        validActionType boolean (1..1)
    set validActionType:
        actionTypefromTrade = ActionTypeEnum -> NEWT
            or actionTypefromTrade = ActionTypeEnum -> MODI
            or actionTypefromTrade = ActionTypeEnum -> CORR
            or actionTypefromTrade = ActionTypeEnum -> REVI
            or actionTypefromTrade = ActionTypeEnum -> POSC

func BeforeTradeByUTI:
    inputs:
        reportableEvent ReportableEvent (1..1)
        afterTradeUTI string (1..1)
    output:
        trade Trade (1..1)
    set trade:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before -> trade
            filter
                item -> tradeIdentifier -> assignedIdentifier -> identifier any = afterTradeUTI
            then only-element

func GetProductQualifier:
    inputs:
        productTaxonomy ProductTaxonomy (0..*)
    output:
        qualifier string (0..1)
    set qualifier:
        productTaxonomy
            extract item -> productQualifier
            then only-element

func CommodityObservablePriceQuantity:
    inputs:
        tradeLot TradeLot (1..1)
        commodityPayout CommodityPayout (1..1)
    output:
        priceQuantity PriceQuantity (1..1)

    alias priceQuantityWithMatchingObservable:
        tradeLot -> priceQuantity
            then filter
                item -> observable -> commodity = commodityPayout -> underlier -> commodity
            then only-element

    alias priceQuantityWithMatchingKey:
        tradeLot -> priceQuantity
            filter
                GetQuantityKeys(item)
                    contains GetQuantityReference(commodityPayout -> priceQuantity)
            then only-element

    set priceQuantity:
        if priceQuantityWithMatchingObservable exists
        then priceQuantityWithMatchingObservable
        else priceQuantityWithMatchingKey

func CommodityForwardObservablePriceQuantity:
    inputs:
        tradeLot TradeLot (1..1)
        forwardPayout ForwardPayout (1..1)
    output:
        priceQuantity PriceQuantity (1..1)

    alias priceQuantityWithMatchingObservable:
        tradeLot -> priceQuantity
            then filter
                item -> observable -> commodity = forwardPayout -> underlier -> commodity
            then only-element

    alias priceQuantityWithMatchingKey:
        tradeLot -> priceQuantity
            filter
                GetQuantityKeys(item)
                    contains GetQuantityReference(forwardPayout -> priceQuantity)
            then only-element

    set priceQuantity:
        if priceQuantityWithMatchingObservable exists
        then priceQuantityWithMatchingObservable
        else priceQuantityWithMatchingKey

func GetQuantityKeys: <"Extract key from each quantity.">
    [codeImplementation]
    inputs:
        priceQuantity PriceQuantity (0..1)
    output:
        keyValues string (0..*)

func GetQuantityReference: <"Extract reference from quantity.">
    [codeImplementation]
    inputs:
        resolvablePriceQuantity ResolvablePriceQuantity (0..1)
    output:
        referenceValue string (0..1)

func AdjustableDateResolution: <"A fall back for unadjustedDate when adjustedDate is only available. If an adjusted date is only provided then fields requiring an unadjusted date are left blank which will result in a NACK from the TR.">
    inputs:
        adjustableDate AdjustableDate (1..1)
    output:
        date date (0..1)

    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

func MinAdjustableDateResolution: <"Finds the earliest date in the list.">
    inputs:
        adjustableDates AdjustableDate (0..*)
    output:
        date date (0..1)

    set date:
        adjustableDates
            extract AdjustableDateResolution(item)
            then min

func AdjustableDatesResolution: <"A fall back for unadjustedDate when adjustedDate is only available. If an adjusted date is only provided then fields requiring an unadjusted date are left blank which will result in a NACK from the TR.">
    inputs:
        adjustableDates AdjustableDates (1..1)
    output:
        date date (0..*)

    add date:
        if adjustableDates -> unadjustedDate exists
        then adjustableDates -> unadjustedDate
        else adjustableDates -> adjustedDate

func AdjustableOrAdjustedOrRelativeDateResolution:
    inputs:
        adjustableDate AdjustableOrAdjustedOrRelativeDate (1..1)
    output:
        date date (0..1)
    set date:
        if adjustableDate -> unadjustedDate exists
        then adjustableDate -> unadjustedDate
        else adjustableDate -> adjustedDate

func IsPackageIndicator: <"">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        packageIndicator boolean (1..1)

    set packageIndicator:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation exists
            or reportableEvent -> originatingWorkflowStep -> businessEvent -> after -> trade -> executionDetails -> packageReference exists

func GetPackageInformation: <"Find package IdentifiedList from TransactionReportInstruction">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        packageInformation IdentifiedList (0..1)

    set packageInformation:
        if reportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation exists
        then reportableEvent -> originatingWorkflowStep -> businessEvent -> packageInformation
        else if TradeForEvent(reportableEvent) -> executionDetails -> packageReference exists
        then TradeForEvent(reportableEvent) -> executionDetails -> packageReference

func GetLeg1ResolvablePriceQuantity:
    inputs:
        trade Trade (1..1)
    output:
        priceQuantity ResolvablePriceQuantity (0..1)

    alias product: ProductForTrade(trade)

    set priceQuantity:
        // IR
        if IsIRSwaption(product)
        then (UnderlierForProduct(product)
            extract InterestRateLeg1(item)
            then extract item -> priceQuantity)
        else if IsGenericIRS(product) or IsCap(product) or IsFloor(product)
        then InterestRateLeg1(product) extract item -> priceQuantity
        // CR
        else if IsCreditSwaption(product)
        then (EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout
            then extract item -> priceQuantity)
        else if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> priceQuantity
        // EQ
        else if IsEquity(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> priceQuantity
        else if IsVolatilitySwap(product) or IsVarianceSwap(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> priceQuantity
        // FX
        else if IsFXForward(product)
        then FXLeg1(product) extract item -> priceQuantity
        else if IsFXOption(product)
        then FXLeg1(product) extract item -> priceQuantity
        else if IsFXSwap(product)
        then FXSwapLeg1(product) -> priceQuantity
        // CO
        else if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
        then FixedPriceLeg1(product) -> priceQuantity
        else if Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
        then CommodityLeg1(product) -> priceQuantity
        else if Qualify_Commodity_Option(EconomicTermsForProduct(product))
        then EconomicTermsForProduct(product) -> payout -> optionPayout only-element -> priceQuantity
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
        then (if Qualify_Commodity_Swap_FixedFloat(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    )
            then FixedPriceLeg1(UnderlierForProduct(product)) -> priceQuantity
            else if Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    )
            then CommodityLeg1(UnderlierForProduct(product)) -> priceQuantity)
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(product))
        then (if IsCommodityFixedPriceForward(product)
            then EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element -> priceQuantity
            else if IsCommodityFloatingPriceForward(product)
            then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> priceQuantity)
        else if IsSingleCommodityPayoutProduct(product)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> priceQuantity

func GetLeg2ResolvablePriceQuantity:
    inputs:
        trade Trade (1..1)
    output:
        priceQuantity ResolvablePriceQuantity (0..1)

    alias product: ProductForTrade(trade)

    set priceQuantity:
        // IR, EQ
        if IsIRSwaption(product)
        then (InterestRateLeg2(UnderlierForProduct(product))
            then extract item -> priceQuantity)
        else if IsGenericIRS(product) or IsEquitySwap(trade -> tradableProduct)
        then InterestRateLeg2(product) extract item -> priceQuantity
        // FX
        else if IsFXForward(product)
        then FXLeg2(product) extract item -> priceQuantity
        else if IsFXOption(product)
        then FXLeg2(product) extract item -> priceQuantity
        else if IsFXSwap(product)
        then FXSwapLeg2(product) -> priceQuantity
        // CO
        else if IsCommoditySwap(product)
        then CommodityLeg2(product) -> priceQuantity
        else if Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
        then CommodityLeg2(UnderlierForProduct(product)) -> priceQuantity
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(product))
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> priceQuantity

func FindLatestAssignedIdentifier:
    inputs:
        tradeIdentifier TradeIdentifier (1..1)
    output:
        assignedIdentifier AssignedIdentifier (1..1)

    alias assignedIdentifiersWithVersion:
        tradeIdentifier -> assignedIdentifier filter version exists

    set assignedIdentifier:
        if assignedIdentifiersWithVersion count = 0
        then tradeIdentifier -> assignedIdentifier last
        else (assignedIdentifiersWithVersion
            sort [ item -> version ]
            then last)

func FloatingReferencePeriod:
    inputs:
        period PeriodEnum (1..1)
    output:
        result FrequencyPeriodEnum (1..1)
    set result:
        if period = PeriodEnum -> D
        then DAIL
        else if period = PeriodEnum -> W
        then WEEK
        else if period = PeriodEnum -> M
        then MNTH
        else if period = PeriodEnum -> Y
        then YEAR

func GetReportableQuantityPeriodLeg1:
    inputs:
        trade Trade (1..1)
    output:
        reportablePeriod cdebase.quantity.NotionalPeriod (1..*)

    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
        then FixedPriceLeg1(ProductForTrade(trade)) -> schedule
        else if Qualify_Commodity_Swap_Basis(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
        then CommodityLeg1(ProductForTrade(trade)) -> schedule
        else if IsSingleCommodityPayoutProduct(ProductForTrade(trade))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> schedule
        else if IsCommodityOption(ProductForTrade(trade))
                or Qualify_Commodity_Swaption(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> optionPayout -> schedule only-element
        else if IsCommodityFloatingPriceForward(trade -> tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> schedule
        else if IsCommodityFixedPriceForward(trade -> tradableProduct -> product)
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> fixedPricePayout only-element -> schedule

    alias quantitySchedule:
        if Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForTrade(trade)))
                or Qualify_AssetClass_Commodity(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then GetLeg1ResolvablePriceQuantity(trade) -> quantitySchedule
        else if IsSingleCommodityPayoutProduct(ProductForTrade(trade))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> priceQuantity -> quantitySchedule

    add reportablePeriod:
        if customizedSchedule exists
        then quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value from quantity period, with dates from customPeriod
                customizedSchedule -> schedulePeriod // then loop through each schedulePeriod
                    filter customPeriod [
                        quantityPeriod -> date = customPeriod -> calculationPeriod -> startDate
                    ]
                    then only-element
                    then extract matchingCustomPeriod [
                        cdebase.quantity.NotionalPeriod {
                            value: quantityPeriod -> value
                                then FormatToShortFraction5DecimalNumber,
                            effectiveDate: matchingCustomPeriod -> calculationPeriod -> startDate,
                            endDate: matchingCustomPeriod -> calculationPeriod -> endDate
                        }
                    ]
            ]
        else quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value and dates from quantity period
                cdebase.quantity.NotionalPeriod {
                    value: quantityPeriod -> value then FormatToShortFraction5DecimalNumber,
                    effectiveDate: quantityPeriod -> date,
                    endDate: empty
                }
            ]

func GetReportableQuantityPeriodLeg2:
    inputs:
        trade Trade (1..1)
    output:
        reportablePeriod cdebase.quantity.NotionalPeriod (1..*)

    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(
                    EconomicTermsForProduct(ProductForTrade(trade))
                )
                or Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then CommodityLeg2(ProductForTrade(trade)) -> schedule
        else if IsSingleCommodityPayoutProduct(ProductForTrade(trade))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> commodityPayout only-element -> schedule
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(ProductForTrade(trade)))
        then EconomicTermsForProduct(ProductForTrade(trade)) -> payout -> forwardPayout only-element -> schedule

    alias quantitySchedule:
        if Qualify_AssetClass_Equity(EconomicTermsForProduct(ProductForTrade(trade)))
                or Qualify_AssetClass_Commodity(
                        EconomicTermsForProduct(ProductForTrade(trade))
                    )
        then GetLeg2ResolvablePriceQuantity(trade) -> quantitySchedule

    add reportablePeriod:
        if customizedSchedule exists
        then quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value from quantity period, with dates from customPeriod
                customizedSchedule -> schedulePeriod // then loop through each schedulePeriod
                    filter customPeriod [
                        quantityPeriod -> date = customPeriod -> calculationPeriod -> startDate
                    ]
                    then only-element
                    then extract matchingCustomPeriod [
                        cdebase.quantity.NotionalPeriod {
                            value: quantityPeriod -> value
                                then FormatToShortFraction5DecimalNumber,
                            effectiveDate: matchingCustomPeriod -> calculationPeriod -> startDate,
                            endDate: matchingCustomPeriod -> calculationPeriod -> endDate
                        }
                    ]
            ]
        else quantitySchedule -> datedValue // loop through each datedValue
            extract quantityPeriod [
                // use value and dates from quantity period
                cdebase.quantity.NotionalPeriod {
                    value: quantityPeriod -> value then FormatToShortFraction5DecimalNumber,
                    effectiveDate: quantityPeriod -> date,
                    endDate: empty
                }
            ]

func GetProductIdentifierFilteringISIN:
    inputs:
        productIdentifiers ProductIdentifier (0..*) <"List of product identifiers">
    output:
        productIdentifier ProductIdentifier (0..1) <"Single product identifier">

    set productIdentifier: <"Extract ISIN identifier if exists, else return the first.">
        if productIdentifiers -> source any = ProductIdTypeEnum -> ISIN
        then (productIdentifiers
            filter source = ProductIdTypeEnum -> ISIN
            then first)
        else productIdentifiers first

func Create_ContinuousPriceSchedule: <"Converts price schedule to a continuous price schedule, where the period end date is the date before the next period start date.">
    [codeImplementation]
    inputs:
        reportablePeriod cdebase.price.PricePeriod (0..*) <"Input schedule may only have start dates specified, or may be discontinous.">
        endDate date (1..1) <"End date of the final period.">
    output:
        continuousReportablePeriod cdebase.price.PricePeriod (0..*)

func Create_ContinuousQuantitySchedule: <"Converts quantity schedule to a continuous quantity schedule, where the period end date is the date before the next period start date.">
    [codeImplementation]
    inputs:
        reportablePeriod cdebase.quantity.NotionalPeriod (0..*) <"Input schedule may only have start dates specified, or may be discontinous.">
        endDate date (1..1) <"End date of the final period.">
    output:
        continuousReportablePeriod cdebase.quantity.NotionalPeriod (0..*)

func GetPriceNotation: <"Notations are manners in which Price Values (Price, Rate or Spread) is expressed.
                        Notation 1 - Represents Monetary Value;
                        Notation 2 - Represents Percentage;
                        Notation 3 - Represents Decimal;
                        Notation 4 - Represents Spread
                        ">
    inputs:
        price PriceSchedule (0..1)
    output:
        notation cdebase.price.PriceNotationEnum (1..1)

    set notation:
        if price -> value exists or price -> datedValue exists
        then if price -> priceType = PriceTypeEnum -> InterestRate
                    and price -> arithmeticOperator = ArithmeticOperationEnum -> Add
            then Basis // 4
            else if (price -> priceType = PriceTypeEnum -> InterestRate
                    or price -> priceType = PriceTypeEnum -> Variance
                    or price -> priceType = PriceTypeEnum -> Volatility
                    or (price -> priceType = PriceTypeEnum -> AssetPrice
                        and price -> unit = price -> perUnitOf))
                    or (price -> priceExpression = PriceExpressionEnum -> PercentageOfNotional)
            then Percentage // 2
            else if (price -> priceType = PriceTypeEnum -> ExchangeRate
                    or price -> priceType = PriceTypeEnum -> AssetPrice
                    or price -> priceType = PriceTypeEnum -> CashPrice)
                    or (price -> unit -> currency exists
                        or price -> priceExpression = PriceExpressionEnum -> AbsoluteTerms)
            then Monetary // 1
            else Decimal // 3

func GetNotationString: <"This functions returns character notations for Business names e.g. This function returns '3' for Notation = 'Decimal'">
    inputs:
        notationEnum cdebase.price.PriceNotationEnum (1..1)
    output:
        notationString NumericChar1to4 (0..1)

    set notationString:
        if notationEnum = Monetary
        then "1"
        else if notationEnum = Percentage
        then "2"
        else if notationEnum = Decimal
        then "3"
        else if notationEnum = Basis
        then "4"

func GetVenueOfExecution: <"Extracts venue of execution from reportable event.">
    inputs:
        reportableInformation ReportableInformation (0..1)
    output:
        venueOfExecution string (0..1)

    set venueOfExecution:
        reportableInformation -> partyInformation -> relatedParty
            filter role = PartyRoleEnum -> ExecutionFacility
            then extract partyReference -> partyId
            then flatten
            then filter identifierType = PartyIdentifierTypeEnum -> MIC
            then extract identifier
            then first

func GetValuation: <"Extracts the valuation history for the max timestamp available">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        valuation Valuation (0..1)

    set valuation:
        if TradeStateForEvent(reportableEvent) -> valuationHistory exists
        then TradeStateForEvent(reportableEvent) -> valuationHistory
            max [ timestamp -> date ]
        else if PositionStateForEvent(reportableEvent) -> valuationHistory exists
        then PositionStateForEvent(reportableEvent) -> valuationHistory
            max [ timestamp -> date ]

func GetNonFinancialCorporateSector:
    inputs:
        nonFinancialSector NonFinancialSector (1..*)
    output:
        corporateSector string (1..*)
    add corporateSector: nonFinancialSector extract nonFinancialSectorIndicator to-string

func GetIndexIndicatorFromFloatingRate:
    inputs:
        floatingRate string (1..1)
    output:
        indicator IndexEnum (0..1)
    set indicator:
        if [
                FloatingRateIndexEnum -> EUR_EuroSTR to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_12M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_1M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_1W to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_3M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Average_6M to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_COMPOUND to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Compounded_Index to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_FTSE_Term to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_OIS_Compound to-string,
                FloatingRateIndexEnum -> EUR_EuroSTR_Term to-string
            ] any = floatingRate
        then ESTR
        else if [
                FloatingRateIndexEnum -> GBP_SONIA to-string,
                FloatingRateIndexEnum -> GBP_SONIA_COMPOUND to-string,
                FloatingRateIndexEnum -> GBP_SONIA_Compounded_Index to-string,
                FloatingRateIndexEnum -> GBP_SONIA_FTSE_Term to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_SONIA_ICE_Term to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_ICAP to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_SONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> GBP_SONIA_Refinitiv_Term to-string,
                FloatingRateIndexEnum -> GBP_SONIA_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_WMBA_SONIA_COMPOUND to-string
            ] any = floatingRate
        then SONA
        else if [
                FloatingRateIndexEnum -> USD_SOFR to-string,
                FloatingRateIndexEnum -> USD_SOFR_Average_180D to-string,
                FloatingRateIndexEnum -> USD_SOFR_Average_30D to-string,
                FloatingRateIndexEnum -> USD_SOFR_Average_90D to-string,
                FloatingRateIndexEnum -> USD_SOFR_CME_Term to-string,
                FloatingRateIndexEnum -> USD_SOFR_COMPOUND to-string,
                FloatingRateIndexEnum -> USD_SOFR_Compounded_Index to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> USD_SOFR_OIS_Compound to-string
            ] any = floatingRate
        then SOFR
        else if [
                FloatingRateIndexEnum -> EUR_EONIA to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_10_00_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> EUR_EONIA_OIS_COMPOUND_Bloomberg to-string
            ] any = floatingRate
        then EONA
        else if [FloatingRateIndexEnum -> EUR_EONIA_Swap_Index to-string] any = floatingRate
        then EONS
        else if [
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_3M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> EUR_6M_EURIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Act_365 to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Act_365_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Annual_Bond_Swap_vs_1m_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Basis_Swap_1m_vs_3m_Euribor_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Basis_Swap_3m_vs_6m_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_ICE_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_ICE_Swap_Rate_12_00 to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Reuters to-string,
                FloatingRateIndexEnum -> EUR_EURIBOR_Telerate to-string
            ] any = floatingRate
        then EURI
        else if [FloatingRateIndexEnum -> EUR_USD_Basis_Swaps_11_00_ICAP to-string] any = floatingRate
        then EUUS
        else if False
        then EUCH
        else if False
        then GCFR
        else if [
                FloatingRateIndexEnum -> CAD_ISDA_Swap_Rate to-string,
                FloatingRateIndexEnum -> CHF_ISDAFIX_Swap_Rate to-string,
                FloatingRateIndexEnum -> EUR_ISDA_EURIBOR_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> EUR_ISDA_EURIBOR_Swap_Rate_12_00 to-string,
                FloatingRateIndexEnum -> EUR_ISDA_LIBOR_Swap_Rate_10_00 to-string,
                FloatingRateIndexEnum -> EUR_ISDA_LIBOR_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> GBP_ISDA_Swap_Rate to-string,
                FloatingRateIndexEnum -> HKD_ISDA_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> HKD_ISDA_Swap_Rate_4_00 to-string,
                FloatingRateIndexEnum -> JPY_ISDA_Swap_Rate_10_00 to-string,
                FloatingRateIndexEnum -> JPY_ISDA_Swap_Rate_15_00 to-string,
                FloatingRateIndexEnum -> USD_ISDAFIX3_Swap_Rate to-string,
                FloatingRateIndexEnum -> USD_ISDAFIX3_Swap_Rate_3_00 to-string,
                FloatingRateIndexEnum -> USD_ISDA_Swap_Rate to-string,
                FloatingRateIndexEnum -> USD_ISDA_Swap_Rate_3_00 to-string
            ] any = floatingRate
        then ISDA
        else if False
        then LIBI
        else if [
                FloatingRateIndexEnum -> AUD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> AUD_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> AUD_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_BBA_SwapMarker to-string,
                FloatingRateIndexEnum -> CAD_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_3M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBORSWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> CHF_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_LIBOR to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> CHF_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_LIBOR to-string,
                FloatingRateIndexEnum -> EUR_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> EUR_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> GBP_6M_LIBOR_SWAP_EUREX_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> GBP_LIBOR to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_ICE_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> GBP_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_LIBOR to-string,
                FloatingRateIndexEnum -> USD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> JPY_LIBOR to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_FRASETT to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_TSR_10_00 to-string,
                FloatingRateIndexEnum -> JPY_LIBOR_TSR_15_00 to-string,
                FloatingRateIndexEnum -> JPY_Quoting_Banks_LIBOR to-string,
                FloatingRateIndexEnum -> USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> USD_3M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP to-string,
                FloatingRateIndexEnum -> USD_6M_LIBOR_SWAP_CME_vs_LCH_ICAP_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_LIBOR to-string,
                FloatingRateIndexEnum -> USD_LIBOR_BBA to-string,
                FloatingRateIndexEnum -> USD_LIBOR_BBA_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_LIBOR_ICE_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> USD_LIBOR_ICE_Swap_Rate_15_00 to-string,
                FloatingRateIndexEnum -> USD_LIBOR_ISDA to-string,
                FloatingRateIndexEnum -> USD_LIBOR_LIBO to-string,
                FloatingRateIndexEnum -> USD_LIBOR_Reference_Banks to-string
            ] any = floatingRate
        then LIBO
        else if [
                FloatingRateIndexEnum -> USD_Municipal_Swap_Index to-string,
                FloatingRateIndexEnum -> USD_Municipal_Swap_Libor_Ratio_11_00_ICAP to-string,
                FloatingRateIndexEnum -> USD_Municipal_Swap_Rate_11_00_ICAP to-string
            ] any = floatingRate
        then MAAA
        else if False
        then PFAN
        else if [
                FloatingRateIndexEnum -> JPY_Euroyen_TIBOR to-string,
                FloatingRateIndexEnum -> JPY_TIBOR to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_17096 to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_17097 to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_DTIBOR01 to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__10_Banks_ to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__5_Banks_ to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__All_Banks_ to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM__All_Banks__Bloomberg to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_TIBM_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_TIBOR_ZTIBOR to-string,
                FloatingRateIndexEnum -> USD_TIBOR_ISDC to-string,
                FloatingRateIndexEnum -> USD_TIBOR_Reference_Banks to-string
            ] any = floatingRate
        then TIBO
        else if [
                FloatingRateIndexEnum -> SEK_STIBOR to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SEK_STIBOR_SIDE to-string
            ] any = floatingRate
        then STBO
        else if [
                FloatingRateIndexEnum -> AUD_BBR_AUBBSW to-string,
                FloatingRateIndexEnum -> AUD_BBR_BBSW to-string,
                FloatingRateIndexEnum -> AUD_BBR_BBSW_Bloomberg to-string,
                FloatingRateIndexEnum -> AUD_BBSW to-string,
                FloatingRateIndexEnum -> AUD_BBSW_Quarterly_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> AUD_BBSW_Semi_Annual_Swap_Rate_ICAP to-string
            ] any = floatingRate
        then BBSW
        else if [
                FloatingRateIndexEnum -> ZAR_JIBAR to-string,
                FloatingRateIndexEnum -> ZAR_JIBAR_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_JIBAR_SAFEX to-string
            ] any = floatingRate
        then JIBA
        else if [
                FloatingRateIndexEnum -> HUF_BUBOR to-string,
                FloatingRateIndexEnum -> HUF_BUBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> HUF_BUBOR_Reuters to-string
            ] any = floatingRate
        then BUBO
        else if [
                FloatingRateIndexEnum -> CAD_BA_CDOR to-string // Some CAD_BA in NSNC
                ,
                FloatingRateIndexEnum -> CAD_BA_CDOR_Bloomberg to-string // Some CAD_BA in NSNC
                ,
                FloatingRateIndexEnum -> CAD_CDOR to-string
            ] any = floatingRate
        then CDOR
        else if [
                FloatingRateIndexEnum -> DKK_CIBOR to-string,
                FloatingRateIndexEnum -> DKK_CIBOR2 to-string,
                FloatingRateIndexEnum -> DKK_CIBOR2_Bloomberg to-string,
                FloatingRateIndexEnum -> DKK_CIBOR2_DKNA13 to-string,
                FloatingRateIndexEnum -> DKK_CIBOR_DKNA13 to-string,
                FloatingRateIndexEnum -> DKK_CIBOR_DKNA13_Bloomberg to-string,
                FloatingRateIndexEnum -> DKK_CIBOR_Reference_Banks to-string
            ] any = floatingRate
        then CIBO
        else if [
                FloatingRateIndexEnum -> RUB_MosPrime to-string,
                FloatingRateIndexEnum -> RUB_MOSPRIME_NFEA to-string,
                FloatingRateIndexEnum -> RUB_MOSPRIME_Reference_Banks to-string
            ] any = floatingRate
        then MOSP
        else if [
                FloatingRateIndexEnum -> NOK_NIBOR to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_NIBR to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_NIBR_Bloomberg to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_NIBR_Reference_Banks to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_OIBOR to-string,
                FloatingRateIndexEnum -> NOK_NIBOR_Reference_Banks to-string
            ] any = floatingRate
        then NIBO
        else if [
                FloatingRateIndexEnum -> CZK_PRIBOR to-string,
                FloatingRateIndexEnum -> CZK_PRIBOR_PRBO to-string,
                FloatingRateIndexEnum -> CZK_PRIBOR_Reference_Banks to-string
            ] any = floatingRate
        then PRBO
        else if [
                FloatingRateIndexEnum -> ILS_TELBOR to-string,
                FloatingRateIndexEnum -> ILS_TELBOR01_Reuters to-string,
                FloatingRateIndexEnum -> ILS_TELBOR_Reference_Banks to-string
            ] any = floatingRate
        then TLBO
        else if [
                FloatingRateIndexEnum -> PLN_WIBOR to-string,
                FloatingRateIndexEnum -> PLN_WIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> PLN_WIBOR_WIBO to-string,
                FloatingRateIndexEnum -> PLZ_WIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> PLZ_WIBOR_WIBO to-string
            ] any = floatingRate
        then WIBO
        else if [
                FloatingRateIndexEnum -> CAD_TBILL_ISDD to-string,
                FloatingRateIndexEnum -> CAD_TBILL_Reference_Banks to-string,
                FloatingRateIndexEnum -> CAD_TBILL_Reuters to-string,
                FloatingRateIndexEnum -> CAD_TBILL_Telerate to-string,
                FloatingRateIndexEnum -> USD_TBILL_Auction_High_Rate to-string,
                FloatingRateIndexEnum -> USD_TBILL_H_15 to-string,
                FloatingRateIndexEnum -> USD_TBILL_H_15_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_TBILL_Secondary_Market to-string,
                FloatingRateIndexEnum -> USD_TBILL_Secondary_Market_Bond_Equivalent_Yield to-string,
                FloatingRateIndexEnum -> USD_Treasury_19901_3_00_ICAP to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_BCMP1 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_ICAP_BrokerTec to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_SwapMarker100 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_SwapMarker99 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_T19901 to-string,
                FloatingRateIndexEnum -> USD_Treasury_Rate_T500 to-string
            ] any = floatingRate
        then TREA
        else if [
                FloatingRateIndexEnum -> AUD_Quarterly_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> AUD_Quarterly_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> AUD_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> AUD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> AUD_Semi_annual_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> AUD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> AUD_Swap_Rate_Reuters to-string,
                FloatingRateIndexEnum -> CHF_Annual_Swap_Rate to-string,
                FloatingRateIndexEnum -> CHF_Annual_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> CHF_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> CHF_Basis_Swap_3m_vs_6m_LIBOR_11_00_ICAP to-string,
                FloatingRateIndexEnum -> CHF_OIS_11_00_ICAP to-string // Maybe not
                ,
                FloatingRateIndexEnum -> CHF_USD_Basis_Swaps_11_00_ICAP to-string,
                FloatingRateIndexEnum -> CNY_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> CNY_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> CZK_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> CZK_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00 to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_10_00_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00 to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00_Bloomberg to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_11_00_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_3_Month to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_3_Month_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> EUR_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_Basis_Swap_EONIA_vs_3m_EUR_IBOR_Swap_Rates_A_360_10_00_ICAP to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> GBP_Semi_Annual_Swap_Rate_SwapMarker26 to-string,
                FloatingRateIndexEnum -> GBP_USD_Basis_Swaps_11_00_ICAP to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_4_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Quarterly_Swap_Rate_11_00_ICAP to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Quarterly_Swap_Rate_4_00_ICAP to-string,
                FloatingRateIndexEnum -> HKD_Quarterly_Quarterly_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> IDR_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> IDR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> IDR_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> INR_Semi_Annual_Swap_Rate_11_30_BGCANTOR to-string,
                FloatingRateIndexEnum -> INR_Semi_Annual_Swap_Rate_Non_deliverable_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> INR_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_Annual_Swap_Rate_3_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_OIS_11_00_ICAP to-string,
                FloatingRateIndexEnum -> JPY_OIS_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_OIS_3_00_TRADITION to-string,
                FloatingRateIndexEnum -> JPY_USD_Basis_Swaps_11_00_ICAP to-string,
                FloatingRateIndexEnum -> KRW_Quarterly_Annual_Swap_Rate_3_30_ICAP to-string,
                FloatingRateIndexEnum -> MYR_Quarterly_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> MYR_Quarterly_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> NZD_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> NZD_Semi_Annual_Swap_Rate_BGCANTOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> NZD_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> NZD_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> PHP_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> PHP_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> RON_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> RON_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_12_45_TRADITION to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_4_15_TRADITION to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> RUB_Annual_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> SEK_Annual_Swap_Rate to-string,
                FloatingRateIndexEnum -> SEK_Annual_Swap_Rate_SESWFI to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Currency_Basis_Swap_Rate_11_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Currency_Basis_Swap_Rate_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_11_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_16_00_Tullett_Prebon to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_ICAP_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> THB_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> TRY_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> TRY_Annual_Swap_Rate_11_15_BGCANTOR to-string,
                FloatingRateIndexEnum -> TRY_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> TRY_Semi_Annual_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> TWD_Quarterly_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> TWD_Quarterly_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> USD_Annual_Swap_Rate_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_Annual_Swap_Rate_4_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_LON_ICAP to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_NY_ICAP to-string,
                FloatingRateIndexEnum -> USD_OIS_11_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_OIS_3_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> USD_OIS_3_00_NY_ICAP to-string,
                FloatingRateIndexEnum -> USD_OIS_4_00_TRADITION to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Term to-string,
                FloatingRateIndexEnum -> USD_SOFR_ICE_Swap_Rate to-string,
                FloatingRateIndexEnum -> USD_Swap_Rate_BCMP1 to-string,
                FloatingRateIndexEnum -> VND_Semi_Annual_Swap_Rate_11_00_BGCANTOR to-string,
                FloatingRateIndexEnum -> VND_Semi_Annual_Swap_Rate_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_Quarterly_Swap_Rate_1_00_TRADITION to-string,
                FloatingRateIndexEnum -> ZAR_Quarterly_Swap_Rate_5_30_TRADITION to-string,
                FloatingRateIndexEnum -> ZAR_Quarterly_Swap_Rate_TRADITION_Reference_Banks to-string
            ] any = floatingRate
        then SWAP
        else if False
        then FUSW
        else if [
                FloatingRateIndexEnum -> USD_Federal_Funds to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_H_15 to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_H_15_Bloomberg to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_H_15_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_OIS_Compound to-string,
                FloatingRateIndexEnum -> USD_Federal_Funds_Reference_Dealers to-string
            ] any = floatingRate
        then EFFR
        else if [FloatingRateIndexEnum -> USD_Overnight_Bank_Funding_Rate to-string] any = floatingRate
        then OBFR
        else if [
                FloatingRateIndexEnum -> CZK_CZEONIA to-string,
                FloatingRateIndexEnum -> CZK_CZEONIA_OIS_Compound to-string
            ] any = floatingRate
        then CZNA
        else if [
                FloatingRateIndexEnum -> CAD_CORRA to-string,
                FloatingRateIndexEnum -> CAD_CORRA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> CAD_CORRA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> CAD_CORRA_Compounded_Index to-string,
                FloatingRateIndexEnum -> CAD_REPO_CORRA to-string
            ] any = floatingRate
        then CORA
        else if [
                FloatingRateIndexEnum -> HKD_HIBOR to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HIBOR_ to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HKAB to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_HKAB_Bloomberg to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_ISDC to-string,
                FloatingRateIndexEnum -> HKD_HIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CNH_HIBOR to-string,
                FloatingRateIndexEnum -> CNH_HIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> CNH_HIBOR_TMA to-string
            ] any = floatingRate
        then HKIO
        else if [
                FloatingRateIndexEnum -> JPY_TONA to-string,
                FloatingRateIndexEnum -> JPY_TONA_Average_180D to-string,
                FloatingRateIndexEnum -> JPY_TONA_Average_30D to-string,
                FloatingRateIndexEnum -> JPY_TONA_Average_90D to-string,
                FloatingRateIndexEnum -> JPY_TONA_Compounded_Index to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_0_Floor to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_0_Floor_2D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_0_Floor_5D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_2D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_ICE_Compounded_Index_5D_Lag to-string,
                FloatingRateIndexEnum -> JPY_TONA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> JPY_TONA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> JPY_TONA_TSR_10_00 to-string
            ] any = floatingRate
        then TONA
        else if [FloatingRateIndexEnum -> JPY_TORF_QUICK to-string] any = floatingRate
        then TORF
        else if [
                FloatingRateIndexEnum -> USD_SIBOR_SIBO to-string,
                FloatingRateIndexEnum -> USD_SIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_SIBOR to-string,
                FloatingRateIndexEnum -> SGD_SIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_SIBOR_Reuters to-string,
                FloatingRateIndexEnum -> SGD_SIBOR_Telerate to-string
            ] any = floatingRate
        then SIBO
        else if [
                FloatingRateIndexEnum -> SGD_SOR to-string,
                FloatingRateIndexEnum -> SGD_SOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SGD_SOR_Reuters to-string,
                FloatingRateIndexEnum -> SGD_SOR_Telerate to-string,
                FloatingRateIndexEnum -> SGD_SOR_VWAP to-string,
                FloatingRateIndexEnum -> SGD_SOR_VWAP_Reference_Banks to-string
            ] any = floatingRate
        then SSOR
        else if [
                FloatingRateIndexEnum -> SGD_SORA to-string,
                FloatingRateIndexEnum -> SGD_SORA_COMPOUND to-string,
                FloatingRateIndexEnum -> SGD_SORA_OIS_Compound to-string
            ] any = floatingRate
        then SORA
        else if [
                FloatingRateIndexEnum -> AED_EBOR_Reuters to-string,
                FloatingRateIndexEnum -> AED_EIBOR to-string,
                FloatingRateIndexEnum -> AUD_AONIA to-string,
                FloatingRateIndexEnum -> AUD_AONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> AUD_AONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> AUD_BBR_BBSY__BID_ to-string,
                FloatingRateIndexEnum -> AUD_BBR_ISDC to-string,
                FloatingRateIndexEnum -> AUD_BBSY_Bid to-string,
                FloatingRateIndexEnum -> BRL_CDI to-string,
                FloatingRateIndexEnum -> CAD_BA_ISDD to-string,
                FloatingRateIndexEnum -> CAD_BA_Reference_Banks to-string,
                FloatingRateIndexEnum -> CAD_BA_Reuters to-string,
                FloatingRateIndexEnum -> CAD_BA_Telerate to-string,
                FloatingRateIndexEnum -> CHF_SARON to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_12M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_1M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_1W to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_2M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_3M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_6M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Average_9M to-string,
                FloatingRateIndexEnum -> CHF_SARON_Compounded_Index to-string,
                FloatingRateIndexEnum -> CHF_SARON_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> CHF_SARON_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> CHF_TOIS_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> CL_CLICP_Bloomberg to-string,
                FloatingRateIndexEnum -> CLP_ICP to-string,
                FloatingRateIndexEnum -> CLP_TNA to-string,
                FloatingRateIndexEnum -> CNY_7_Repo_Compounding_Date to-string,
                FloatingRateIndexEnum -> CNY_CNREPOFIX_CFXS_Reuters to-string,
                FloatingRateIndexEnum -> CNY_Deposit_Rate to-string,
                FloatingRateIndexEnum -> CNY_Fixing_Repo_Rate to-string,
                FloatingRateIndexEnum -> CNY_LPR to-string,
                FloatingRateIndexEnum -> CNY_PBOCB_Reuters to-string,
                FloatingRateIndexEnum -> CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION to-string,
                FloatingRateIndexEnum -> CNY_Quarterly_7_day_Repo_Non_Deliverable_Swap_Rate_TRADITION_Reference_Banks to-string,
                FloatingRateIndexEnum -> CNY_Quarterly_7D_Repo_NDS_Rate_Tradition to-string,
                FloatingRateIndexEnum -> CNY_SHIBOR to-string,
                FloatingRateIndexEnum -> CNY_SHIBOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> CNY_Shibor_OIS_Compounding to-string,
                FloatingRateIndexEnum -> CNY_SHIBOR_Reuters to-string,
                FloatingRateIndexEnum -> COP_IBR_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> COP_IBR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> DKK_CITA to-string,
                FloatingRateIndexEnum -> DKK_CITA_DKNA14_COMPOUND to-string,
                FloatingRateIndexEnum -> DKK_DESTR to-string,
                FloatingRateIndexEnum -> DKK_DESTR_Compounded_Index to-string,
                FloatingRateIndexEnum -> DKK_DESTR_OIS_Compound to-string,
                FloatingRateIndexEnum -> DKK_DKKOIS_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> DKK_Tom_Next_OIS_Compound to-string,
                FloatingRateIndexEnum -> EUR_CNO_TEC10 to-string,
                FloatingRateIndexEnum -> EUR_EURONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> EUR_EURONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> EUR_TAM_CDC to-string,
                FloatingRateIndexEnum -> EUR_TEC10_CNO to-string,
                FloatingRateIndexEnum -> EUR_TEC10_CNO_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_TEC10_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_TEC5_CNO to-string,
                FloatingRateIndexEnum -> EUR_TEC5_CNO_SwapMarker to-string,
                FloatingRateIndexEnum -> EUR_TEC5_Reference_Banks to-string,
                FloatingRateIndexEnum -> EUR_TMM_CDC_COMPOUND to-string,
                FloatingRateIndexEnum -> GBP_RONIA to-string,
                FloatingRateIndexEnum -> GBP_RONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> GBP_UK_Base_Rate to-string,
                FloatingRateIndexEnum -> GBP_WMBA_RONIA_COMPOUND to-string,
                FloatingRateIndexEnum -> GRD_ATHIBOR_ATHIBOR to-string,
                FloatingRateIndexEnum -> GRD_ATHIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> GRD_ATHIBOR_Telerate to-string,
                FloatingRateIndexEnum -> GRD_ATHIMID_Reference_Banks to-string,
                FloatingRateIndexEnum -> GRD_ATHIMID_Reuters to-string,
                FloatingRateIndexEnum -> HKD_HONIA to-string,
                FloatingRateIndexEnum -> HKD_HONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> HKD_HONIX_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> HUF_HUFONIA to-string,
                FloatingRateIndexEnum -> HUF_HUFONIA_OIS_Compound to-string,
                FloatingRateIndexEnum -> IDR_IDMA_Bloomberg to-string,
                FloatingRateIndexEnum -> IDR_IDRFIX to-string,
                FloatingRateIndexEnum -> IDR_JIBOR to-string,
                FloatingRateIndexEnum -> IDR_JIBOR_Reuters to-string,
                FloatingRateIndexEnum -> IDR_SBI_Reuters to-string,
                FloatingRateIndexEnum -> IDR_SOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> IDR_SOR_Reuters to-string,
                FloatingRateIndexEnum -> IDR_SOR_Telerate to-string,
                FloatingRateIndexEnum -> ILS_SHIR to-string,
                FloatingRateIndexEnum -> ILS_SHIR_OIS_Compound to-string,
                FloatingRateIndexEnum -> INR_BMK to-string,
                FloatingRateIndexEnum -> INR_CMT to-string,
                FloatingRateIndexEnum -> INR_FBIL_MIBOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> INR_INBMK_REUTERS to-string,
                FloatingRateIndexEnum -> INR_MIBOR_OIS to-string,
                FloatingRateIndexEnum -> INR_MIBOR_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> INR_MIBOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> INR_MIFOR to-string,
                FloatingRateIndexEnum -> INR_MIOIS to-string,
                FloatingRateIndexEnum -> INR_MITOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> INR_Modified_MIFOR to-string,
                FloatingRateIndexEnum -> INR_Reference_Banks to-string,
                FloatingRateIndexEnum -> ISK_REIBOR to-string,
                FloatingRateIndexEnum -> ISK_REIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> ISK_REIBOR_Reuters to-string,
                FloatingRateIndexEnum -> JPY_BBSF_Bloomberg_10_00 to-string,
                FloatingRateIndexEnum -> JPY_BBSF_Bloomberg_15_00 to-string,
                FloatingRateIndexEnum -> JPY_LTPR_MHBK to-string,
                FloatingRateIndexEnum -> JPY_LTPR_MHCB to-string,
                FloatingRateIndexEnum -> JPY_LTPR_TBC to-string,
                FloatingRateIndexEnum -> JPY_MUTANCALL_TONAR to-string,
                FloatingRateIndexEnum -> JPY_STPR_Quoting_Banks to-string,
                FloatingRateIndexEnum -> JPY_TSR_Reference_Banks to-string,
                FloatingRateIndexEnum -> JPY_TSR_Reuters_10_00 to-string,
                FloatingRateIndexEnum -> JPY_TSR_Reuters_15_00 to-string,
                FloatingRateIndexEnum -> JPY_TSR_Telerate_10_00 to-string,
                FloatingRateIndexEnum -> JPY_TSR_Telerate_15_00 to-string,
                FloatingRateIndexEnum -> KRW_Bond_3222 to-string,
                FloatingRateIndexEnum -> KRW_CD_3220 to-string,
                FloatingRateIndexEnum -> KRW_CD_91D to-string,
                FloatingRateIndexEnum -> KRW_CD_KSDA_Bloomberg to-string,
                FloatingRateIndexEnum -> KRW_KOFR to-string,
                FloatingRateIndexEnum -> KRW_KOFR_OIS_Compound to-string,
                FloatingRateIndexEnum -> MXN_TIIE to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Banxico to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Banxico_Bloomberg to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Banxico_Reference_Banks to-string,
                FloatingRateIndexEnum -> MXN_TIIE_ON to-string,
                FloatingRateIndexEnum -> MXN_TIIE_ON_OIS_Compound to-string,
                FloatingRateIndexEnum -> MXN_TIIE_Reference_Banks to-string,
                FloatingRateIndexEnum -> MYR_KLIBOR to-string,
                FloatingRateIndexEnum -> MYR_KLIBOR_BNM to-string,
                FloatingRateIndexEnum -> MYR_KLIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> MYR_MYOR to-string,
                FloatingRateIndexEnum -> MYR_MYOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> NOK_NOWA to-string,
                FloatingRateIndexEnum -> NOK_NOWA_OIS_Compound to-string,
                FloatingRateIndexEnum -> NZD_BBR_BID to-string,
                FloatingRateIndexEnum -> NZD_BBR_FRA to-string,
                FloatingRateIndexEnum -> NZD_BBR_ISDC to-string,
                FloatingRateIndexEnum -> NZD_BBR_Reference_Banks to-string,
                FloatingRateIndexEnum -> NZD_BBR_Telerate to-string,
                FloatingRateIndexEnum -> NZD_BKBM_Bid to-string,
                FloatingRateIndexEnum -> NZD_BKBM_FRA to-string,
                FloatingRateIndexEnum -> NZD_BKBM_FRA_Swap_Rate_ICAP to-string,
                FloatingRateIndexEnum -> NZD_NZIONA to-string,
                FloatingRateIndexEnum -> NZD_NZIONA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> NZD_NZIONA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> PHP_PHIREF to-string,
                FloatingRateIndexEnum -> PHP_PHIREF_BAP to-string,
                FloatingRateIndexEnum -> PHP_PHIREF_Bloomberg to-string,
                FloatingRateIndexEnum -> PHP_PHIREF_Reference_Banks to-string,
                FloatingRateIndexEnum -> PLN_POLONIA to-string,
                FloatingRateIndexEnum -> PLN_POLONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> PLN_POLONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> PLN_WIBID to-string,
                FloatingRateIndexEnum -> PLN_WIRON to-string,
                FloatingRateIndexEnum -> PLN_WIRON_OIS_Compound to-string,
                FloatingRateIndexEnum -> REPOFUNDS_RATE_FRANCE_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> REPOFUNDS_RATE_GERMANY_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> REPOFUNDS_RATE_ITALY_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> RON_RBOR_Reuters to-string,
                FloatingRateIndexEnum -> RON_ROBID to-string,
                FloatingRateIndexEnum -> RON_ROBOR to-string,
                FloatingRateIndexEnum -> RUB_Key_Rate_CBRF to-string,
                FloatingRateIndexEnum -> RUB_RUONIA to-string,
                FloatingRateIndexEnum -> RUB_RUONIA_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> RUB_RUONIA_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> SAR_SAIBOR to-string,
                FloatingRateIndexEnum -> SAR_SRIOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> SAR_SRIOR_SUAA to-string,
                FloatingRateIndexEnum -> SEK_SIOR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> SEK_SWESTR to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_1M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_1W to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_2M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_3M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Average_6M to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_Compounded_Index to-string,
                FloatingRateIndexEnum -> SEK_SWESTR_OIS_Compound to-string,
                FloatingRateIndexEnum -> SGD_SONAR_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> SGD_SONAR_OIS_VWAP_COMPOUND to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_BRBO to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_NBSK07 to-string,
                FloatingRateIndexEnum -> SKK_BRIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_SOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_SOR_Reuters to-string,
                FloatingRateIndexEnum -> THB_SOR_Telerate to-string,
                FloatingRateIndexEnum -> THB_THBFIX to-string,
                FloatingRateIndexEnum -> THB_THBFIX_Reference_Banks to-string,
                FloatingRateIndexEnum -> THB_THBFIX_Reuters to-string,
                FloatingRateIndexEnum -> THB_THOR to-string,
                FloatingRateIndexEnum -> THB_THOR_COMPOUND to-string,
                FloatingRateIndexEnum -> THB_THOR_OIS_Compound to-string,
                FloatingRateIndexEnum -> TRY_TLREF to-string,
                FloatingRateIndexEnum -> TRY_TLREF_OIS_Compound_1 to-string,
                FloatingRateIndexEnum -> TRY_TLREF_OIS_COMPOUND to-string,
                FloatingRateIndexEnum -> TRY_TRLIBOR to-string,
                FloatingRateIndexEnum -> TRY_TRYIBOR_Reference_Banks to-string,
                FloatingRateIndexEnum -> TRY_TRYIBOR_Reuters to-string,
                FloatingRateIndexEnum -> TWD_Reference_Dealers to-string,
                FloatingRateIndexEnum -> TWD_Reuters_6165 to-string,
                FloatingRateIndexEnum -> TWD_TAIBIR01 to-string,
                FloatingRateIndexEnum -> TWD_TAIBIR02 to-string,
                FloatingRateIndexEnum -> TWD_TAIBOR to-string,
                FloatingRateIndexEnum -> TWD_TAIBOR_Bloomberg to-string,
                FloatingRateIndexEnum -> TWD_TAIBOR_Reuters to-string,
                FloatingRateIndexEnum -> TWD_Telerate_6165 to-string,
                FloatingRateIndexEnum -> TWD_TWCPBA to-string,
                FloatingRateIndexEnum -> UK_Base_Rate to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Average_30D to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Average_90D to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Term to-string,
                FloatingRateIndexEnum -> USD_AMERIBOR_Term_Structure to-string,
                FloatingRateIndexEnum -> USD_AXI_Term to-string,
                FloatingRateIndexEnum -> USD_BA_H_15 to-string,
                FloatingRateIndexEnum -> USD_BA_Reference_Dealers to-string,
                FloatingRateIndexEnum -> USD_BMA_Municipal_Swap_Index to-string,
                FloatingRateIndexEnum -> USD_BSBY to-string,
                FloatingRateIndexEnum -> USD_CD_H_15 to-string,
                FloatingRateIndexEnum -> USD_CD_Reference_Dealers to-string,
                FloatingRateIndexEnum -> USD_CMS_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_CMS_Reference_Banks_ICAP_SwapPX to-string,
                FloatingRateIndexEnum -> USD_CMS_Reuters to-string,
                FloatingRateIndexEnum -> USD_CMS_Telerate to-string,
                FloatingRateIndexEnum -> USD_CMT to-string,
                FloatingRateIndexEnum -> USD_CMT_Average_1W to-string,
                FloatingRateIndexEnum -> USD_CMT_T7051 to-string,
                FloatingRateIndexEnum -> USD_CMT_T7052 to-string,
                FloatingRateIndexEnum -> USD_COF11_FHLBSF to-string,
                FloatingRateIndexEnum -> USD_COF11_Reuters to-string,
                FloatingRateIndexEnum -> USD_COF11_Telerate to-string,
                FloatingRateIndexEnum -> USD_COFI to-string,
                FloatingRateIndexEnum -> USD_CP_H_15 to-string,
                FloatingRateIndexEnum -> USD_CP_Money_Market_Yield to-string,
                FloatingRateIndexEnum -> USD_CP_Reference_Dealers to-string,
                FloatingRateIndexEnum -> USD_CRITR to-string,
                FloatingRateIndexEnum -> USD_FFCB_DISCO to-string,
                FloatingRateIndexEnum -> USD_FXI_Term to-string,
                FloatingRateIndexEnum -> USD_Prime to-string,
                FloatingRateIndexEnum -> USD_Prime_H_15 to-string,
                FloatingRateIndexEnum -> USD_Prime_Reference_Banks to-string,
                FloatingRateIndexEnum -> USD_S_P_Index_High_Grade to-string,
                FloatingRateIndexEnum -> USD_SandP_Index_High_Grade to-string,
                FloatingRateIndexEnum -> USD_SIFMA_Municipal_Swap_Index to-string /* Maybe MAAA */ ,
                FloatingRateIndexEnum -> ZAR_DEPOSIT_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_DEPOSIT_SAFEX to-string,
                FloatingRateIndexEnum -> ZAR_Prime_Average_1 to-string,
                FloatingRateIndexEnum -> ZAR_PRIME_AVERAGE to-string,
                FloatingRateIndexEnum -> ZAR_PRIME_AVERAGE_Reference_Banks to-string,
                FloatingRateIndexEnum -> ZAR_ZARONIA to-string,
                FloatingRateIndexEnum -> ZAR_ZARONIA_OIS_Compound to-string
            ] any = floatingRate
        then empty

func GetNameOfTheFloatingRateOfLeg1:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        name string (0..1)
    set name:
        ProductForEvent(reportableEvent)
            then filter IsFRA = False
            then extract ProductOrUnderlierProduct
            then extract InterestRateLeg1
            then extract RateOption -> indexReferenceInformation -> indexName

func GetNameOfTheFloatingRateOfLeg2:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        name string (0..1)
    set name:
        ProductForEvent(reportableEvent)
            then extract ProductOrUnderlierProduct
            then extract InterestRateLeg2
            then extract RateOption -> indexReferenceInformation -> indexName

func GetFinancialCorporateSector:
    inputs:
        financialSector FinancialSectorEnum (0..*)
    output:
        corporateSector string (0..*)
    add corporateSector: financialSector extract to-string

func IsEU: <"Function to check if Country Code supplied belongs to European Union.">
    inputs:
        countryCode string (1..1)
    output:
        result boolean (1..1)
    set result:
        if ["BE", "BG", "CZ", "DK", "DE", "EE", "IE", "EL", "ES", "FR", "HR", "IT", "CY", "LV", "LT", "LU", "HU", "MT", "NL", "AT", "PL", "PT", "RO", "SI", "SK", "FI", "SE"] any = countryCode
        then True
        else False

func IsESMAThirdCountryEquivalentMarket: <"Function to check if the MIC supplied refers to third country market considered as equivalent to regulated market by ESMA.">
    [regulatoryReference ESMA EMIR annex "ESMA70-708036281-113"
        provision "List of third-country markets considered as equivalent to a regulated market in the Union for the purposes of the definition of OTC derivatives. The markets established in a third country and listed below have been considered as equivalent to a regulated market in the Union in accordance with Article 2a of Regulation (EU) No 648/2012 of the European Parliament and of the Council of 4 July 2012 on OTC derivatives, central counterparties and trade repositories (EMIR) and for the purposes of Article 2(7) of this Regulation.
            Link to the Document: https://www.esma.europa.eu/sites/default/files/library/equivalent_tc-markets_under_emir.pdf"]
    inputs:
        mic string (1..1)
    output:
        result boolean (1..1)
    set result:
        /*  The Following mic codes refer to the list of Execution Venue as mentioned in the document published by ESMA.
         *     The list is ordered in accordance to the order in the document by ESMA.
         *     No mic code is available for No. 16 - North American Derivatives Exchange, Inc.
         */
        if ["BTNL", "XBOX", "XCFF", "XCBF", "BATS", "C2OX", "EDGX", "XCBO", "XCBT", "XCME", "XCEC", "XELX", "ERIS", "IFUS", "KLSH", "LEDG", "FREX", "XMIO", "EMLD", "MPRL", "XMGE", "GMNI", "XISX", "XBOS", "MCRY", "XPHL", "XNDQ", "XNYM", "NODX", "HEGX", "AMXO", "ARCX", "XOCH", "SMFE", "TRUX", "XASX", "XSFE", "CHIA", "XFEX", "XMOD", "XCNQ", "IFCA", "NGXC", "XTSX", "XTNX", "XATS", "NEOC", "XTKS", "XOSE", "XNGO", "XFKA", "XSAP", "XTFF", "XKAC", "XTKT", "XSIM", "XSES", "IFSG"] any = mic
        then True
        else False

func IsFCAThirdCountryEquivalentMarket: <"Function to check if the MIC supplied refers to third country market considered as equivalent to regulated market by FCA.">
    [regulatoryReference FCA UKEMIR
        provision "List of third-country markets considered as equivalent to a regulated market in the UK for the purposes of the definition of OTC derivatives. The third country markets listed below have been considered to be equivalent to a UK regulated market in accordance with article 2a of UK EMIR.
            Link to the Document: https://www.fca.org.uk/publication/fca/fca-list-regulated-markets.pdf"]
    inputs:
        mic string (1..1)
    output:
        result boolean (1..1)
    set result:
        /*  The Following mic codes refer to the list of Execution Venue as mentioned in the document published by FCA.
         *     The list is ordered in accordance to the order in the document by FCA.
         *     No mic code is available for North American Derivatives Exchange, Inc.
         */
        if ["XASX", "XSFE", "CHIA", "WBAH", "XBRD", "XBRU", "ZBUL", "IBUL", "ABUL", "NEOE", "XATS", "XMOD", "XCNQ", "NGXC", "XTSX", "XTSX", "XCXD", "XZAG", "XCYS", "XPRA", "XRMZ", "XCSE", "DCSE", "MCSE", "XTAL", "XHEL", "MHEL", "DHEL", "XMON", "XPAR", "XMAT", "DUSA", "BERA", "BERC", "STUC", "STUA", "HAMM", "HAMA", "HANA", "DUSC", "MUNC", "XEER", "MUNA", "EQTB", "EQTA", "XGRM", "FRAA", "XETA", "XEUR", "XETU", "XPSF", "HDAT", "XATH", "XADE", "HEDE", "ASEX", "HUDX", "XBUD", "MICE", "XICE", "DICE", "XMSM", "ETFP", "MTAA", "MOTX", "MIVX", "XDMI", "MTSC", "XTKS", "XOSE", "XNGO", "XFKA", "XSAP", "XTFF", "XKAC", "XTKT", "XRIS", "XLIT", "XLUX", "XMAL", "IFSM", "XNXC", "NDEX", "XEUE", "XEUC", "BTAM", "CCRM", "BEUT", "BARU", "BEUO", "XAMS", "IMEQ", "FISH", "NORX", "NEXO", "ELNO", "ELEU", "ELSE", "XOAS", "XOSL", "XOBD", "WBCL", "PLPD", "WOPO", "RPWC", "WETP", "WIND", "WIPO", "XWAR", "WBON", "WDER", "MFOX", "OMIP", "XLIS", "XBSE", "XSIM", "XSES", "IFSG", "XBRA", "XLJU", "SEND", "MERF", "SBAR", "XMRV", "XMPW", "SBIL", "XDRF", "XBIL", "XVAL", "XMAD", "XBAR", "XMFX", "EUWB", "FIED", "XSTO", "DKED", "EBON", "NOCO", "SEED", "PNED", "USWB", "NOFI", "DKFI", "DSTO", "NOED", "MSTO", "ESTO", "GBWB", "XNGM", "BTNL", "XCFF", "XCBF", "XCBT", "XCME", "XCEC", "ERIS", "IFUS", "KLSH", "LEDG", "FREX", "XMGE", "XNYM", "NODX", "HEGX", "SMFE"] any = mic
        then True
        else False

func IsValidRefEntity:
    inputs:
        refEntity string (1..1)
    output:
        validRefEntity boolean (1..1)

    alias validFormat: <"Valid pattern contains 2 characters, followed by optional part contains a hyphen and 3 characters.">
        StringContains(refEntity, "[A-Z]{2}(-[A-Z]{3})?")
    alias validCountryCode: SubString(refEntity, 1, 2) to-enum ISOCountryCodeEnum exists

    set validRefEntity: validCountryCode and validFormat

func LastAvailableSpotPrice:
    inputs:
        reportableInformation ReportableInformation (1..1)
    output:
        lastAvailableSpotPrice PriceSchedule (0..1)
    // Last Available Spot Price will be found in the tradeLot for Commodity Basis Swaps.
    // This is the only price in this kind of products which is not a spread. It is an Asset Price also.
    set lastAvailableSpotPrice:
        reportableInformation -> underlyingAssetLastAvailableSpotPrice

func CommodityBasisLegWithNoSpread:
    inputs:
        product Product (1..1)
    output:
        commodityPayout CommodityPayout (0..1)
    // This function takes, from the two commodity payouts of a commodity basis, the one which does not have an spread or which has an spread = 0
    set commodityPayout:
        EconomicTermsForProduct(product) -> payout -> commodityPayout
            filter
                commodityPriceReturnTerms -> spread is absent
                    or commodityPriceReturnTerms -> spread -> price -> value = 0
            then only-element

func GetReportableDelivery: <"Extracts the period for a price schedule">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportableDelivery ReportableDelivery (0..*)
    alias product: ProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(product)
    alias delivery:
        if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then economicTerms -> payout -> commodityPayout -> delivery first
        else if Qualify_Commodity_Option(economicTerms)
        then economicTerms -> payout -> optionPayout -> delivery only-element
        else if Qualify_Commodity_Swaption(economicTerms)
        then EconomicTermsForProduct(
                economicTerms -> payout -> optionPayout -> underlier only-element
            ) -> payout -> commodityPayout -> delivery first
        else if IsSingleCommodityPayoutProduct(product)
        then economicTerms -> payout -> commodityPayout only-element -> delivery
        else if Qualify_Commodity_Forward(economicTerms)
        then economicTerms -> payout -> forwardPayout only-element -> delivery
    alias customizedSchedule:
        if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then economicTerms -> payout -> commodityPayout -> schedule first
        else if Qualify_Commodity_Option(economicTerms)
                or Qualify_Commodity_Swaption(economicTerms)
        then economicTerms -> payout -> optionPayout only-element -> schedule
        else if IsSingleCommodityPayoutProduct(product)
        then economicTerms -> payout -> commodityPayout only-element -> schedule
        else if Qualify_Commodity_Forward(economicTerms)
        then economicTerms -> payout -> forwardPayout only-element -> schedule
    alias duration:
        reportableEvent -> reportableInformation -> transactionInformation -> esmaTransactionInformation -> duration first
    add reportableDelivery:
        if customizedSchedule exists
        then (customizedSchedule -> schedulePeriod
            extract schedulePeriod [
                schedulePeriod -> deliveryPeriod -> profile
                    extract deliveryProfile [
                        deliveryProfile -> block
                            extract deliveryBlock [
                                Create_DeliveryBlock(
                                        deliveryBlock -> startTime,
                                        deliveryBlock -> endTime,
                                        schedulePeriod -> deliveryPeriod -> startDate,
                                        schedulePeriod -> deliveryPeriod -> endDate,
                                        deliveryProfile -> bankHolidaysTreatment,
                                        duration,
                                        deliveryBlock -> dayOfWeek,
                                        if schedulePeriod -> deliveryPeriod -> deliveryCapacity exists
                                        then schedulePeriod -> deliveryPeriod -> deliveryCapacity
                                        else if deliveryBlock -> deliveryCapacity exists
                                        then deliveryBlock -> deliveryCapacity,
                                        if schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
                                        then schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity -> value
                                        else if deliveryBlock -> priceTimeIntervalQuantity exists
                                        then deliveryBlock -> priceTimeIntervalQuantity -> value,
                                        if schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity exists
                                        then schedulePeriod -> deliveryPeriod -> priceTimeIntervalQuantity -> unit -> currency
                                        else if deliveryBlock -> priceTimeIntervalQuantity exists
                                        then deliveryBlock -> priceTimeIntervalQuantity -> unit -> currency
                                    )
                            ]
                    ]
                    then flatten
            ]
            then flatten)
        else delivery -> periods
            extract periods [
                periods -> profile
                    extract deliveryProfile [
                        deliveryProfile -> block
                            extract deliveryBlock [
                                Create_DeliveryBlock(
                                        deliveryBlock -> startTime,
                                        deliveryBlock -> endTime,
                                        periods -> startDate,
                                        periods -> endDate,
                                        deliveryProfile -> bankHolidaysTreatment,
                                        duration,
                                        deliveryBlock -> dayOfWeek,
                                        if delivery -> deliveryCapacity exists
                                        then delivery -> deliveryCapacity
                                        else if deliveryBlock -> deliveryCapacity exists
                                        then deliveryBlock -> deliveryCapacity,
                                        deliveryBlock -> priceTimeIntervalQuantity -> value,
                                        deliveryBlock -> priceTimeIntervalQuantity -> unit -> currency
                                    )
                            ]
                    ]
                    then flatten
            ]

func Create_DeliveryBlock:
    inputs:
        deliveryStartTime time (0..1)
        deliveryEndTime time (0..1)
        deliveryStartDate date (0..1)
        deliveryEndDate date (0..1)
        bankHolidaysTreatment BankHolidayTreatmentEnum (0..1)
        duration CommodityTimeUnitEnum (0..1)
        daysOfTheWeek DayOfWeekEnum (0..7)
        deliveryCapacity Quantity (0..1)
        priceTimeIntervalQuantity number (0..1)
        currencyOfThePriceTimeIntervalQuantity string (0..1)
    output:
        deliveryBlock ReportableDelivery (1..1)
    set deliveryBlock:
        ReportableDelivery {
            deliveryStartTime: deliveryStartTime,
            deliveryEndTime: deliveryEndTime,
            deliveryStartDate: deliveryStartDate,
            deliveryEndDate: deliveryEndDate,
            duration: GetDurationCodeFromCommodityTimeUnit(duration),
            daysOfTheWeek: GetDaysOfTheWeek(daysOfTheWeek, bankHolidaysTreatment),
            deliveryCapacity: GetDeliveryCapacityAmount(deliveryCapacity),
            quantityUnit: GetDeliveryCapacityUnit(deliveryCapacity),
            priceTimeIntervalQuantity: priceTimeIntervalQuantity,
            currencyOfThePriceTimeIntervalQuantity: currencyOfThePriceTimeIntervalQuantity
        }

func GetDaysOfTheWeek:
    inputs:
        daysOfTheWeek DayOfWeekEnum (0..7)
        bankHolidaysTreatment BankHolidayTreatmentEnum (0..1)
    output:
        dayCode string (0..*)
    alias mon: daysOfTheWeek contains DayOfWeekEnum -> MON
    alias tue: daysOfTheWeek contains DayOfWeekEnum -> TUE
    alias wed: daysOfTheWeek contains DayOfWeekEnum -> WED
    alias thu: daysOfTheWeek contains DayOfWeekEnum -> THU
    alias fri: daysOfTheWeek contains DayOfWeekEnum -> FRI
    alias sat: daysOfTheWeek contains DayOfWeekEnum -> SAT
    alias sun: daysOfTheWeek contains DayOfWeekEnum -> SUN
    add dayCode: // MOND
        if mon and (tue = False or wed = False or thu = False or fri = False)
        then "MOND"
    add dayCode: // TUED
        if tue and (mon = False or wed = False or thu = False or fri = False)
        then "TUED"
    add dayCode: // WEDD
        if wed and (mon = False or tue = False or thu = False or fri = False)
        then "WEDD"
    add dayCode: // THUD
        if thu and (mon = False or tue = False or wed = False or fri = False)
        then "THUD"
    add dayCode: // FRID
        if fri and (mon = False or tue = False or wed = False or thu = False)
        then "FRID"
    add dayCode: // SATD
        if sat and (sun = False) then "SATD"
    add dayCode: // SUND
        if sun and (sat = False) then "SUND"
    add dayCode: // WDAY
        if mon and tue and wed and thu and fri then "WDAY"
    add dayCode: // WEND
        if sat and sun then "WEND"
    add dayCode:
        if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekday
                and (mon or tue or wed or thu or fri)
                and ((sat or sun) = False)
        then "IBHL"
        else if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekend
                and (sat or sun)
                and ((mon or tue or wed or thu or fri) = False)
        then "IBHL"
    add dayCode:
        if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekend
                and (mon or tue or wed or thu or fri)
                and ((sat or sun) = False)
        then "XBHL"
        else if bankHolidaysTreatment = BankHolidayTreatmentEnum -> AsWeekday
                and (sat or sun)
                and ((mon or tue or wed or thu or fri) = False)
        then "XBHL"

func GetDurationCodeFromCommodityTimeUnit: <"Function to get the duration of a delivery profile from CommodityTimeUnitEnum to DurationType1Code">
    inputs:
        timeUnit CommodityTimeUnitEnum (1..1)
    output:
        duration DurationType1Code (1..1)
    set duration:
        if timeUnit = CommodityTimeUnitEnum -> Minute
        then DurationType1Code -> MNUT
        else if timeUnit = CommodityTimeUnitEnum -> Hour
        then DurationType1Code -> HOUR
        else if timeUnit = CommodityTimeUnitEnum -> Day
        then DurationType1Code -> DASD
        else if timeUnit = CommodityTimeUnitEnum -> Week
        then DurationType1Code -> WEEK
        else if timeUnit = CommodityTimeUnitEnum -> Month
        then DurationType1Code -> QURT
        else if timeUnit = CommodityTimeUnitEnum -> Season
        then DurationType1Code -> SEAS
        else if timeUnit = CommodityTimeUnitEnum -> Year
        then DurationType1Code -> YEAR
        else if timeUnit = CommodityTimeUnitEnum -> Other
        then DurationType1Code -> OTHR

func GetLoadType: <"Function to get the load type of a delivery profile from LoadTypeEnum to EnergyLoadType1Code">
    inputs:
        profile AssetDeliveryProfile (1..1)
    output:
        loadType EnergyLoadType1Code (1..1)
    set loadType:
        if profile -> loadType = LoadTypeEnum -> BaseLoad
        then EnergyLoadType1Code -> BSLD
        else if profile -> loadType = LoadTypeEnum -> PeakLoad
        then EnergyLoadType1Code -> PKLD
        else if profile -> loadType = LoadTypeEnum -> OffPeak
        then EnergyLoadType1Code -> OFFP
        else if profile -> loadType = LoadTypeEnum -> BlockHours
        then EnergyLoadType1Code -> HABH
        else if profile -> loadType = LoadTypeEnum -> Shaped
        then EnergyLoadType1Code -> SHPD
        else if profile -> loadType = LoadTypeEnum -> GasDay
        then EnergyLoadType1Code -> GASD
        else if profile -> loadType = LoadTypeEnum -> Other
        then EnergyLoadType1Code -> OTHR

func GetDeliveryCapacityAmount:
    inputs:
        deliveryCapacity Quantity (0..1)
    output:
        amount number (0..1)
    set amount: QuantityToDeliveryCapacity(deliveryCapacity) -> amount

func GetDeliveryCapacityUnit:
    inputs:
        deliveryCapacity Quantity (0..1)
    output:
        unit EnergyQuantityUnit2Code (0..1)
    set unit: QuantityToDeliveryCapacity(deliveryCapacity) -> unit

func QuantityToDeliveryCapacity:
    inputs:
        quantity Quantity (0..1)
    output:
        deliveryCapacity DeliveryCapacity (0..1)
    alias capacityUnit: quantity -> unit -> capacityUnit
    alias frequency: quantity -> frequency
    set deliveryCapacity:
        // POWER UNITS
        if capacityUnit = CapacityUnitEnum -> KW
        then DeliveryCapacity {
                amount: quantity -> value,
                unit: EnergyQuantityUnit2Code -> KWAT
            }
        else if capacityUnit = CapacityUnitEnum -> MW
        then DeliveryCapacity {
                amount: quantity -> value,
                unit: EnergyQuantityUnit2Code -> MWAT
            }
        else if capacityUnit = CapacityUnitEnum -> GW
        then DeliveryCapacity {
                amount: quantity -> value,
                unit: EnergyQuantityUnit2Code -> GWAT
            }
        // BRITISH THERMAL UNITS
        else if [CapacityUnitEnum -> GBBTU, CapacityUnitEnum -> ISOBTU, CapacityUnitEnum -> USBTU] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> BTUD
                })
        else if [CapacityUnitEnum -> GBMBTU, CapacityUnitEnum -> ISOMBTU, CapacityUnitEnum -> USMBTU] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: (1000.0 * quantity -> value) / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> BTUD
                })
        else if [CapacityUnitEnum -> GBMMBTU, CapacityUnitEnum -> ISOMMBTU, CapacityUnitEnum -> USMMBTU] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MBTD
                })
        // CUBIC METERS
        else if capacityUnit = CapacityUnitEnum -> CBM
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        else if capacityUnit = CapacityUnitEnum -> L
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / (frequency -> periodMultiplier * 1000.0),
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        else if capacityUnit = CapacityUnitEnum -> HL
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / (frequency -> periodMultiplier * 10.0),
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        else if capacityUnit = CapacityUnitEnum -> KL
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> CMPD
                })
        // JOULES
        else if capacityUnit = CapacityUnitEnum -> MJ
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MJDD
                })
        else if capacityUnit = CapacityUnitEnum -> GJ
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> GJDD
                })
        // WATT*TIME UNITS
        else if capacityUnit = CapacityUnitEnum -> KWH
        then (if frequency -> period = PeriodExtendedEnum -> H
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> KWHH
                }
            else if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> KWHD
                })
        else if capacityUnit = CapacityUnitEnum -> MWH
        then (if frequency -> period = PeriodExtendedEnum -> H
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MWHH
                }
            else if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> MWHD
                })
        else if capacityUnit = CapacityUnitEnum -> GWH
        then (if frequency -> period = PeriodExtendedEnum -> H
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> GWHH
                }
            else if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> GWHD
                })
        // THERMAL UNITS
        else if [CapacityUnitEnum -> GBTHM, CapacityUnitEnum -> ISOTHM, CapacityUnitEnum -> USTHM] any = capacityUnit
        then (if frequency -> period = PeriodExtendedEnum -> D
            then DeliveryCapacity {
                    amount: quantity -> value / frequency -> periodMultiplier,
                    unit: EnergyQuantityUnit2Code -> THMD
                })

func ExtractDateFromDateTime:
    inputs:
        dateTimeInput zonedDateTime (1..1)
    output:
        dateOutput date (1..1)

    set dateOutput: dateTimeInput -> date

func IsFRA:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result: Qualify_InterestRate_Fra(EconomicTermsForProduct(product)) = True

func Get_OptionPremiumOnEventDate:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        optionPremium Transfer (0..1)
    alias eventDate:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> eventDate
    alias premiums:
        reportableEvent -> originatingWorkflowStep -> businessEvent -> after -> transferHistory
            filter transfer -> transferExpression -> priceTransfer = FeeTypeEnum -> Premium
            then transfer
    set optionPremium:
        if premiums count = 1
        then premiums only-element
        else if premiums count > 1
        then (premiums max [ AdjustableOrAdjustedOrRelativeDateResolution(settlementDate) ])

func GetUnderlyingIdentificationType:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result trade.underlier.UnderlyingIdentificationTypeEnum (0..1)
    alias product:
        if IsCreditSwaption(ProductForEvent(reportableEvent))
                or IsIRSwaption(ProductForEvent(reportableEvent))
        then UnderlierForProduct(ProductForEvent(reportableEvent))
        else ProductForEvent(reportableEvent)
    set result:
        if (UnderlierForProduct(product) -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                    and UnderlierForProduct(product) -> security -> economicTerms -> payout -> forwardPayout -> underlier -> index is absent) // exclude Option on Future on index
                or UnderlierForProduct(product) -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> index -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                    // Commodities: only for ETDs
                or (IsProductETD(product)
                    and ((EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
                            and IsSingleCommodityPayoutProduct(product) = False
                        or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN
                        or UnderlierForProduct(product) -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN))
                        // IR on bond
                or (EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond -> source any = ProductIdTypeEnum -> ISIN)
                or (EconomicTermsForProduct(product) -> payout -> optionPayout -> underlier -> index -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
                or (EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> commodity -> productIdentifier -> source any = ProductIdTypeEnum -> ISIN)
        then trade.underlier.UnderlyingIdentificationTypeEnum -> I
        else if UnderlierForProduct(product) -> basket exists
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> basket exists
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
                or EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation exists
                    // Commodities: only for ETDs
                or (IsProductETD(product)
                    and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> basket exists
                    and IsSingleCommodityPayoutProduct(product) = False)
        then trade.underlier.UnderlyingIdentificationTypeEnum -> B
        else if UnderlierForProduct(product) -> index exists
                or EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> index exists
                or EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
                or EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
                    // IR Swaps floating or inflation rate
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> floatingRate exists
                or EconomicTermsForProduct(product) -> payout -> interestRatePayout -> rateSpecification -> inflationRate exists
                    // Commodities: only for ETDs
                or (IsProductETD(product)
                    and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index exists
                    and IsSingleCommodityPayoutProduct(product) = False)
                or Qualify_InterestRate_Fra(EconomicTermsForProduct(product))
                    // ETD Option on Futures on Index
                or (IsProductETD(product)
                    and UnderlierForProduct(UnderlierForProduct(product)) -> index exists)
        then trade.underlier.UnderlyingIdentificationTypeEnum -> X

func IsSingleCommodityPayoutProduct: //IsSingleCommodityPayoutProduct
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    alias economicTerms: EconomicTermsForProduct(product)
    set result:
        // EconomicTermsForProduct(product) -> payout -> commodityPayout only-element exists
        // and EconomicTermsForProduct(product) -> payout -> fixedPricePayout is absent
        // and EconomicTermsForProduct(product) -> payout -> interestRatePayout is absent
        economicTerms -> payout -> commodityPayout only exists
            and economicTerms -> payout -> commodityPayout count = 1

func ConvertNonISOToISOCurrency:
    inputs:
        nonISOCurrency string (0..1)
    output:
        isoCurrency ISOCurrencyCodeEnum (0..1)

    set isoCurrency:
        if nonISOCurrency = "CNH"
        then (if nonISOCurrency = "CNH" then ISOCurrencyCodeEnum -> CNY)
        else nonISOCurrency to-enum ISOCurrencyCodeEnum

func DeliveryTypeForProducts:
    inputs:
        product Product (1..1)
    output:
        deliveryType DeliveryTypeEnum (1..1)

    alias settlementLeg:
        if SettlementTermsLeg1(product) exists
        then SettlementTermsLeg1(product)
        else SettlementTermsLeg2(product)

    alias deliveryTypeFromSettlementLeg:
        if (settlementLeg -> settlementType = SettlementTypeEnum -> Cash or settlementLeg -> cashSettlementTerms exists)
        then DeliveryTypeEnum -> CASH
        else if (settlementLeg -> settlementType = SettlementTypeEnum -> Physical
                or settlementLeg -> physicalSettlementTerms exists)
        then DeliveryTypeEnum -> PHYS
        else if (settlementLeg -> settlementType = SettlementTypeEnum -> CashOrPhysical or settlementLeg -> settlementType = SettlementTypeEnum -> Election)
        then DeliveryTypeEnum -> OPTL

    set deliveryType:
        if [DeliveryTypeEnum -> CASH, DeliveryTypeEnum -> PHYS, DeliveryTypeEnum -> OPTL] any = deliveryTypeFromSettlementLeg
        then deliveryTypeFromSettlementLeg
        else if Qualify_AssetClass_InterestRate(EconomicTermsForProduct(product)) // CASH if it is a non-deliverable product, in which case cashSettlementTerms would be populated, therefore never reaching this instance
        then DeliveryTypeEnum -> PHYS
        else if Qualify_AssetClass_Equity(EconomicTermsForProduct(product))
        then (if IsVarianceSwap(product)
                    or IsVolatilitySwap(product)
                    or product -> index -> productTaxonomy -> primaryAssetClass any = AssetClassEnum -> Equity
                    or UnderlierForProduct(product) -> index -> productTaxonomy -> primaryAssetClass any = AssetClassEnum -> Equity
            then DeliveryTypeEnum -> CASH)
        else if Qualify_AssetClass_Credit(EconomicTermsForProduct(product))
        then DeliveryTypeEnum -> OPTL
        else if Qualify_AssetClass_ForeignExchange(EconomicTermsForProduct(product))
        then (if Qualify_ForeignExchange_NDF(EconomicTermsForProduct(product))
                    or // This instance should never be reached
                    Qualify_ForeignExchange_NDS(EconomicTermsForProduct(product))
            // NDO
            then DeliveryTypeEnum -> CASH
            else if Qualify_ForeignExchange_Swap(EconomicTermsForProduct(product))
                    or Qualify_ForeignExchange_Spot_Forward(
                            EconomicTermsForProduct(product)
                        )
                    or Qualify_ForeignExchange_VanillaOption(
                            EconomicTermsForProduct(product)
                        )
            then DeliveryTypeEnum -> PHYS)
        else if Qualify_AssetClass_Commodity(EconomicTermsForProduct(product))
        then (if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
                    or Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
                    or Qualify_Commodity_Option_Cash(EconomicTermsForProduct(product)) // This should never be reached
            then DeliveryTypeEnum -> CASH
            else if Qualify_Commodity_Forward(EconomicTermsForProduct(product))
                    or Qualify_Commodity_Option_Physical(EconomicTermsForProduct(product))
                    or // This should never be reached
                    Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
            then DeliveryTypeEnum -> PHYS)

func GetExpirationDate:
    inputs:
        transactionReportInstruction TransactionReportInstruction (1..1)
    output:
        expirationDate date (0..1)

    alias product: ProductForEvent(transactionReportInstruction)
    alias fixingDates: InterestRateLeg2(product) -> resetDates -> fixingDates
    alias periodMultiplier:
        if fixingDates -> periodMultiplier exists
        then fixingDates -> periodMultiplier
        else 0

    set expirationDate:
        if Qualify_InterestRate_Fra(product -> contractualProduct -> economicTerms)
        then AddBusinessDays(
                    cde.datetime.EffectiveDate(transactionReportInstruction),
                    periodMultiplier,
                    fixingDates -> businessCenters -> businessCenter
                )
        else cde.datetime.ExpirationDate(product)

func GetReportTrackingNumber:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        reportingTrackingNumber string (0..1)

    alias role:
        FilterPartyRole(
                TradeForEvent(reportableEvent) -> partyRole,
                PartyRoleEnum -> ExecutionFacility
            ) -> partyReference only-element

    set reportingTrackingNumber:
        TradeForEvent(reportableEvent) -> tradeIdentifier
            filter issuerReference = role
            then extract assignedIdentifier -> identifier
            then flatten
            then if item exists then item else "RTNNotProvided"
            then only-element

// TH 28/03/25 Update: Supervisory Body input unbounded to accept multiple supervisory bodies
func GetRegimeSpecificIdentifiers:
    inputs:
        reportableInformation ReportableInformation (1..1)
        supervisoryBody SupervisoryBodyEnum (1..*)
        tradeIdentifierType TradeIdentifierTypeEnum (1..1)
    output:
        regimeSpecificIdentifiers string (0..*)

    alias regimeTransactionIds:
        reportableInformation -> transactionInformation
            then filter supervisoryBody any = item -> supervisoryBody
            then transactionIdentifier filter identifierType = tradeIdentifierType

    add regimeSpecificIdentifiers:
        if regimeTransactionIds exists
        then regimeTransactionIds -> assignedIdentifier -> identifier

func ETDNotionalOption:
    inputs:
        optionPayout OptionPayout (0..1)
        tradeLot TradeLot (0..*)
    output:
        notional Measure (1..1)
    alias quantityCurrency:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> currency exists
            then extract value
            then only-element
    alias quantityFinancial:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> financialUnit exists
            then extract value
            then only-element

    alias strikePrice: optionPayout -> exerciseTerms -> strike -> strikePrice

    alias amount: // todo: consider contractSize
        // Monetary schedule
        if tradeLot only-element -> priceQuantity -> quantity -> unit -> currency exists
        then quantityCurrency
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then quantityFinancial * strikePrice -> value
    alias amountUnit:
        // Monetary schedule
        if tradeLot -> priceQuantity -> quantity -> unit -> currency exists
        then (tradeLot only-element -> priceQuantity -> quantity
            then filter unit -> currency exists
            then only-element
            then extract unit)
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then strikePrice -> unit

    set notional:
        Measure {
            value: amount,
            unit: amountUnit
        }

func ETDNotionalFuture:
    inputs:
//        product Product (0..1)
        tradeLot TradeLot (0..*)
    output:
        notional Measure (1..1)

    alias quantityCurrency:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> currency exists
            then extract value
            then only-element
    alias quantityFinancial:
        tradeLot only-element -> priceQuantity -> quantity
            filter unit -> financialUnit exists
            then extract value
            then only-element

    alias price: tradeLot only-element -> priceQuantity -> price only-element

    alias amount: // todo: consider contractSize
        // Monetary schedule
        if tradeLot only-element -> priceQuantity -> quantity -> unit -> currency exists
        then quantityCurrency
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then quantityFinancial * price -> value

    alias amountUnit:
        // Monetary schedule
        if tradeLot only-element -> priceQuantity -> quantity -> unit -> currency exists
        then (tradeLot only-element -> priceQuantity -> quantity
            then filter unit -> currency exists
            then only-element
            then extract unit)
        // Non-monetary Schedule
        else if tradeLot only-element -> priceQuantity -> quantity -> unit -> financialUnit exists
        then price -> unit

    set notional:
        Measure {
            value: amount,
            unit: amountUnit
        }

func IsRegulatedMarketOrThirdCountryEquivalentMarket: <"Returns True if the venue of execution of the trade is populated with a MIC code of a trading venue that was a regulated market or a third-country market considered as equivalent.">
    inputs:
        reportableInformation ReportableInformation (1..1)
        regime RegimeNameEnum (1..1)
    output:
        result boolean (1..1)

    alias getMic:
        GetOrFetchMicData(
                reportableInformation -> enrichment -> micData,
                GetVenueOfExecution(reportableInformation)
            )

    set result:
        if regime = RegimeNameEnum -> EMIR
        then (getMic -> marketCategoryEsma = MicMarketCategoryEnum -> RMKT // executed in a regulated market
                or IsESMAThirdCountryEquivalentMarket(getMic -> mic) = True // executed in a third country market considered as equivalent to regulated market
                )
        else if regime = RegimeNameEnum -> UKEMIR
        then (getMic -> marketCategoryFca = MicMarketCategoryEnum -> RMKT // executed in a regulated market
                or IsFCAThirdCountryEquivalentMarket(getMic -> mic) = True // executed in a third country market considered as equivalent to regulated market
                )
        else False

func GetCollateralBalancesForMarginType: <"'GetCollateralBalancesForMarginType' is a custom function that fetches Collateral Balances for required Margin Type.">
    inputs:
        reportableCollateral ReportableCollateral (1..1)
        marginType CollateralMarginTypeEnum (1..1)
    output:
        collateralBalances CollateralBalance (0..*)

    add collateralBalances:
        reportableCollateral -> collateralDetails -> collateral -> collateralPortfolio
            filter
                legalAgreement -> legalAgreementIdentification -> agreementName -> creditSupportAgreementMarginType = marginType
            then extract collateralBalance
            then flatten

func GetMarginValue: <"'GetMarginValue' is a custom function that fetches Collateral Margin values for the required Margin Type.">
    inputs:
        partyCollateralBalances CollateralBalance (0..*)
        haircutType HaircutIndicatorEnum (1..1)
    output:
        marginValue Money (0..1)

    set marginValue:
        partyCollateralBalances
            filter haircutIndicator = haircutType
            then filter collateralBalanceStatus = CollateralStatusEnum -> FullAmount
            then extract amountBaseCurrency
            then only-element

func GetMarginCurrency: <"'GetMarginCurrency' is a custom function that fetches Collateral Margin currency for the required Margin Type.">
    inputs:
        partyCollateralBalances CollateralBalance (0..*)
    output:
        marginCurrency ISOCurrencyCodeEnum (0..1)

    /*
     * Rationale Reference: The rationale for the following code snippet is discussed in ISDA DRR Technical Execution Working Group on July 27' 2023.
     * Rationale: Current structure of CDM Collateral Object allows margin currency to be posted for each type of Haircut (Pre or Post). ESMA EMIR regulatory Rules does not specify the type of haircut to be considered for margin currency. This code snippet ensures and checks for both pre and post currency to be same.
     */
    set marginCurrency:
        if (GetMarginValue(partyCollateralBalances, HaircutIndicatorEnum -> PreHaircut) -> unit -> currency = GetMarginValue(
                    partyCollateralBalances,
                    HaircutIndicatorEnum -> PostHaircut
                ) -> unit -> currency)
        then (GetMarginValue(partyCollateralBalances, HaircutIndicatorEnum -> PreHaircut) -> unit -> currency
            then extract ConvertNonISOToISOCurrency)

func GetExecutionTimestamp:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        executionTime zonedDateTime (0..1)

    set executionTime:
        if reportableEvent -> reportableInformation -> originalExecutionTimestamp exists
        then reportableEvent -> reportableInformation -> originalExecutionTimestamp
        else (reportableEvent -> originatingWorkflowStep -> timestamp
            filter qualification = EventTimestampQualificationEnum -> executionDateTime
            then extract dateTime
            then only-element)

func GetModificationTimestamp:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        modificationTime zonedDateTime (0..1)

    set modificationTime:
        reportableEvent -> originatingWorkflowStep -> timestamp
            filter qualification = EventTimestampQualificationEnum -> executionDateTime
            then extract dateTime
            then max

func PayoutLeg1:
    inputs:
        product Product (1..1)
        tradeLot TradeLot (0..1)
        reportableInformation ReportableInformation (0..1)
    output:
        payoutLeg PayoutLegWithAuxiliary (0..1)

    set payoutLeg:
        if IsCreditSwaption(product)
        then PayoutLegWithAuxiliary {
                creditDefaultPayout: EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout,
                ...
            }
        else if IsCreditDefaultSwap(product)
        then PayoutLegWithAuxiliary {
                creditDefaultPayout: EconomicTermsForProduct(product) -> payout -> creditDefaultPayout,
                ...
            }
        else if IsEquityOption(product)
                or IsInterestRateDebtOption(product)
                or (IsProductETD(product) and EconomicTermsForProduct(product) -> payout -> optionPayout exists)
        then PayoutLegWithAuxiliary {
                optionPayout: EconomicTermsForProduct(product) -> payout -> optionPayout only-element,
                tradeLot: tradeLot,
                isProductETD: IsProductETD(product),
                ...
            }
        else if Qualify_Equity_OtherOption(EconomicTermsForProduct(product))
                or Qualify_Credit_OptionOther(EconomicTermsForProduct(product))
                or Qualify_Commodity_OptionOther(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                optionPayout: EconomicTermsForProduct(product) -> payout -> optionPayout only-element,
                ...
            }
        else if Qualify_InterestRate_Option_Swaption(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg1(UnderlierForProduct(product)),
                ...
            }
        else if IsEquityForward(product)
                or (IsProductETD(product) and EconomicTermsForProduct(product) -> payout -> forwardPayout exists)
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                tradeLot: tradeLot,
                isProductETD: IsProductETD(product),
                ...
            }
        else if IsEquity(product)
                or IsTotalReturnSwapDebtUnderlier(product)
                or IsCreditTotalReturnSwap(product)
        then PayoutLegWithAuxiliary {
                performancePayout: EconomicTermsForProduct(product) -> payout -> performancePayout only-element,
                tradeLot: tradeLot,
                ...
            }
        else if IsFXForward(product) or IsFXOption(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXLeg1(product),
                ...
            }
        else if IsFXSwap(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXSwapLeg1(product),
                ...
            }
        else if IsCommodityOption(product)
        then PayoutLegWithAuxiliary {
                optionPayout: EconomicTermsForProduct(product) -> payout -> optionPayout only-element,
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                isProductETD: IsProductETD(product),
                ...
            }
        else if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                fixedPricePayout: EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element,
                ...
            }
        else if (Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
                and Qualify_Commodity_Swap_FixedFloat(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    ))
        then PayoutLegWithAuxiliary {
                fixedPricePayout: EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> fixedPricePayout only-element,
                ...
            }
        else if (Qualify_Commodity_Swaption(EconomicTermsForProduct(product))
                and Qualify_Commodity_Swap_Basis(
                        EconomicTermsForProduct(UnderlierForProduct(product))
                    ))
        then PayoutLegWithAuxiliary {
                commodityPayout: if LastAvailableSpotPrice(reportableInformation) exists
                    then CommodityBasisLegWithNoSpread(UnderlierForProduct(product))
                else CommodityLeg1(UnderlierForProduct(product)),
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                commodityPayout: if LastAvailableSpotPrice(reportableInformation) exists
                    then CommodityBasisLegWithNoSpread(product)
                else CommodityLeg1(product),
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsSingleCommodityPayoutProduct(product)
        then PayoutLegWithAuxiliary {
                commodityPayout: EconomicTermsForProduct(product) -> payout -> commodityPayout only-element,
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsCommodityFixedPriceForward(product)
        then PayoutLegWithAuxiliary {
                fixedPricePayout: EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element,
                ...
            }
        else if IsCommodityFloatingPriceForward(product)
        then PayoutLegWithAuxiliary {
                commodityPayout: EconomicTermsForProduct(product) -> payout -> commodityPayout only-element,
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsCommodityForward(product)
                and EconomicTermsForProduct(product) -> payout -> forwardPayout
                    only-element
                    exists
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                ...
            }
        else if IsFixedFloatZeroCouponSwapKnownAmount(product)
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg2FixedFloatSingleCurrency(product),
                ...
            }
        else if Qualify_InterestRate_Forward_Debt(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                ...
            }
        else if Qualify_AssetClass_InterestRate(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg1(product),
                ...
            }

func PayoutLeg2:
    inputs:
        product Product (1..1)
        tradeLot TradeLot (0..1)
        reportableInformation ReportableInformation (0..1)
    output:
        payoutLeg PayoutLegWithAuxiliary (0..1)

    set payoutLeg:
        if Qualify_InterestRate_Option_Swaption(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg2(UnderlierForProduct(product)),
                ...
            }
        else if IsFXForward(product) or IsFXOption(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXLeg2(product),
                ...
            }
        else if IsFXSwap(product)
        then PayoutLegWithAuxiliary {
                cashflow: FXSwapLeg2(product),
                ...
            }
        else if Qualify_Commodity_Swap_FixedFloat(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                commodityPayout: CommodityLeg2(product),
                auxiliaryLeg: PayoutLeg {
                    fixedPricePayout: FixedPriceLeg1(product),
                    ...
                },
                ...
            }
        else if Qualify_Commodity_Swap_Basis(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                commodityPayout: if LastAvailableSpotPrice(reportableInformation) exists
                    then CommodityBasisLegWithNoSpread(product)
                else CommodityLeg2(product),
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if IsCommodityFixedPriceForward(product)
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                auxiliaryLeg: PayoutLeg {
                    fixedPricePayout: EconomicTermsForProduct(product) -> payout -> fixedPricePayout only-element,
                    ...
                },
                ...
            }
        else if IsCommodityFloatingPriceForward(product)
        then PayoutLegWithAuxiliary {
                forwardPayout: EconomicTermsForProduct(product) -> payout -> forwardPayout only-element,
                auxiliaryLeg: PayoutLeg {
                    commodityPayout: EconomicTermsForProduct(product) -> payout -> commodityPayout only-element,
                    ...
                },
                tradeLot: tradeLot,
                lastAvailableSpotPrice: LastAvailableSpotPrice(reportableInformation),
                ...
            }
        else if Qualify_AssetClass_InterestRate(EconomicTermsForProduct(product))
                or Qualify_AssetClass_Equity(EconomicTermsForProduct(product))
                or Qualify_AssetClass_Credit(EconomicTermsForProduct(product))
        then PayoutLegWithAuxiliary {
                interestRatePayout: InterestRateLeg2(product),
                ...
            }

func GetContractType:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        contractType CommonContractType (0..1)

    set contractType:
        ProductForEvent(reportableEvent)
            then extract
                if IsProductETD
                then (if EconomicTermsForProduct -> payout -> forwardPayout only exists
                    then FUTR
                    else if EconomicTermsForProduct -> payout -> optionPayout only exists
                    then OPTN
                    else OTHR)
                else (if IsFRA
                then FRAS
                else if Qualify_ForeignExchange_Spot_Forward(
                            contractualProduct -> economicTerms
                        )
                        or Qualify_ForeignExchange_NDF(contractualProduct -> economicTerms)
                        or IsSingleCommodityPayoutProduct
                        or IsCommodityForward
                        or Qualify_InterestRate_Forward_Debt(EconomicTermsForProduct)
                        or (Qualify_EquityForward_PriceReturnBasicPerformance_SingleIndex(
                                contractualProduct -> economicTerms
                            )
                            or Qualify_EquityForward_PriceReturnBasicPerformance_SingleName(
                                    contractualProduct -> economicTerms
                                )
                            or Qualify_EquityForward_PriceReturnBasicPerformance_Basket(
                                    contractualProduct -> economicTerms
                                ))
                then FORW
                else if IsIRSwaption or IsCreditSwaption or IsCommoditySwaption
                then SWPT
                else if Qualify_InterestRate_CapFloor(EconomicTermsForProduct)
                        or (EconomicTermsForProduct -> payout -> optionPayout only exists
                            and (EconomicTermsForProduct -> nonStandardisedTerms is absent or EconomicTermsForProduct -> nonStandardisedTerms = False))
                then OPTN
                else if Qualify_BaseProduct_IRSwap(contractualProduct -> economicTerms)
                        or Qualify_BaseProduct_Inflation(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_BaseProduct_CrossCurrency(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon(
                                contractualProduct -> economicTerms
                            )
                        or (Qualify_AssetClass_Credit(contractualProduct -> economicTerms)
                            and (EconomicTermsForProduct -> nonStandardisedTerms is absent or EconomicTermsForProduct -> nonStandardisedTerms = False))
                        or (Qualify_BaseProduct_EquitySwap(
                                contractualProduct -> economicTerms
                            )
                            and IsEquityOther = False) // Checking of Base product is Equity but its not an exotic product
                        or Qualify_Commodity_Swap_FixedFloat(
                                contractualProduct -> economicTerms
                            )
                        or Qualify_Commodity_Swap_Basis(contractualProduct -> economicTerms)
                        or IsFXSwap
                        or contractualProduct -> economicTerms -> payout -> performancePayout only exists
                then SWAP
                else if IsProductETD and EconomicTermsForProduct -> payout -> forwardPayout only exists
                then FUTR
                else OTHR)

func ExtractProductIdentifierBySource: <"This function extracts the identifiers as per the order prescribed 1. RIC, 2. BBTICKER or 3. Name">
    inputs:
        productIdentifiers ProductIdentifier (0..*)
    output:
        productIdentifier ProductIdentifier (0..1)

    alias orderedSources:
        [ProductIdTypeEnum -> RIC, ProductIdTypeEnum -> BBGTICKER, ProductIdTypeEnum -> Name]

    set productIdentifier:
        orderedSources
            extract src [
                productIdentifiers
                    filter source = src
                    then first
            ]
            then first
                    // if no matches then default to the first in the list
                    default productIdentifiers first

func IsMax32UpperCaseAlphanumericText:
    inputs:
        text string (1..1)
    output:
        result boolean (1..1)
    set result: StringContains(text, "^[A-Z0-9]{18}[0-9]{2}[A-Z0-9]{0,32}$")

func GetUnderlierProductIdentifierLeg1: <"Extracts a product identifier from the product underlier of leg 1.">
    inputs:
        product Product (1..1)
    output:
        productId ProductIdentifier (0..*)

    add productId:
        // Every underlier for Options and Forwards
        if UnderlierForProduct(product) exists
        then UnderlierForProduct(product)
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
                else if index exists
                then index -> productIdentifier
                else if basket exists
                then basket -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productId:
        // Commodities
        if EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier -> commodity -> productIdentifier
        else if IsCommoditySwaption(product)
                and CommodityLeg1(UnderlierForProduct(product)) -> underlier -> commodity -> productIdentifier exists
        then CommodityLeg1(UnderlierForProduct(product)) -> underlier -> commodity -> productIdentifier
        else if IsCommoditySwap(product)
                and CommodityLeg1(product) -> underlier -> commodity -> productIdentifier exists
        then CommodityLeg1(product) -> underlier -> commodity -> productIdentifier
        else if CommodityLeg1(product) -> underlier -> basket -> productIdentifier exists
        then CommodityLeg1(product) -> underlier -> basket -> productIdentifier
        // Commodities Index
        else if CommodityLeg1(product) -> underlier -> index exists
        then CommodityLeg1(product) -> underlier -> index -> productIdentifier
        // Swaptions
        else if UnderlierForProduct(product) -> contractualProduct -> productIdentifier exists
        then UnderlierForProduct(product) -> contractualProduct -> productIdentifier
        // IR on bond
        else if InterestRateLeg1(product) -> bondReference -> bond exists
        then InterestRateLeg1(product) -> bondReference -> bond
        // Option on Futures on Index
        else if UnderlierForProduct(UnderlierForProduct(product)) -> index exists
        then UnderlierForProduct(UnderlierForProduct(product)) -> index -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

func GetUnderlierProductIdentifierLeg2: <"Extracts a product identifier from the product underlier of leg 2.">
    inputs:
        product Product (1..1)
    output:
        productId ProductIdentifier (0..*)

    add productId:
        if EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
        else if EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productId:
        // Commodities
        if IsCommoditySwaption(product)
                and CommodityLeg2(UnderlierForProduct(product)) -> underlier -> commodity -> productIdentifier exists
        then CommodityLeg2(UnderlierForProduct(product)) -> underlier -> commodity -> productIdentifier
        else if IsCommoditySwap(product)
                and CommodityLeg2(product) -> underlier -> commodity -> productIdentifier exists
        then CommodityLeg2(product) -> underlier -> commodity -> productIdentifier
        else if CommodityLeg2(product) -> underlier -> basket -> productIdentifier exists
        then CommodityLeg2(product) -> underlier -> basket -> productIdentifier
        // Commodities Index
        else if CommodityLeg2(product) -> underlier -> index exists
        then CommodityLeg2(product) -> underlier -> index -> productIdentifier
        // IR on bond
        else if InterestRateLeg2(product) -> bondReference -> bond exists
        then InterestRateLeg2(product) -> bondReference -> bond
            then extract GetProductIdentifierFilteringISIN

func GetOtherUnderlierLeg1: <"Extracts the underlier ID Other leg 1 from Interest Rate and Foreign Exchange products.">
    inputs:
        product Product (1..1)
    output:
        otherId string (0..1)

    set otherId:
        if IsFRA(product)
                and InterestRateLeg1(product) -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexId is absent
        then InterestRateLeg1(product) -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName
        else if IsFXForward(product) or IsFXOption(product)
        then ConvertCurrency(cdebase.quantity.FXNotionalCurrency(FXLeg1(product)))
        else if IsFXSwap(product)
        then ConvertCurrency(cdebase.quantity.FXNotionalCurrency(FXSwapLeg1(product)))

func GetOtherUnderlierLeg2: <"Extracts the underlier ID Other leg 2 from Interest Rate and Foreign Exchange products.">
    inputs:
        product Product (1..1)
    output:
        otherId string (0..1)

    alias economicTerms: EconomicTermsForProduct(product)

    set otherId:
        if (economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
                and economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId is absent)
        then economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if (EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation exists
                and EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexId is absent)
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName
        else if IsFRA(product)
                and InterestRateLeg2(product) -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexId is absent
        then InterestRateLeg2(product) -> rateSpecification -> floatingRate -> rateOption -> indexReferenceInformation -> indexName
        else if IsFXForward(product) or IsFXOption(product)
        then ConvertCurrency(cdebase.quantity.FXNotionalCurrency(FXLeg2(product)))
        else if IsFXSwap(product)
        then ConvertCurrency(cdebase.quantity.FXNotionalCurrency(FXSwapLeg2(product)))

func GetUnderlierProductIdentifier: <"Extracts a product identifier from the product underlier using an ISIN filtering.">
    inputs:
        product Product (1..1)
    output:
        productId ProductIdentifier (0..*)

    add productId:
        if EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
        else if EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productId:
        if UnderlierForProduct(product) exists
        then UnderlierForProduct(product)
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
                else if index exists
                then index -> productIdentifier
                else if commodity exists and IsProductETD(product)
                then commodity -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

    add productId:
        if (IsProductETD(product)
                and UnderlierForProduct(product) -> commodity -> productIdentifier exists)
        then UnderlierForProduct(product) -> commodity -> productIdentifier
        else if (IsProductETD(product)
                and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier exists
                and IsSingleCommodityPayoutProduct(product) = False)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
        // swaptions
        else if UnderlierForProduct(product) -> contractualProduct -> productIdentifier exists
        then UnderlierForProduct(product) -> contractualProduct -> productIdentifier
        // IR on bond
        else if EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond exists
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond
        // FRA on Commodity
        else if EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> commodity exists
        then EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> commodity -> productIdentifier
        // Commodities Index: only for ETDs
        else if (IsProductETD(product)
                and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index exists
                and IsSingleCommodityPayoutProduct(product) = False)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index -> productIdentifier
        // ETD Option on Futures on Index
        else if (IsProductETD(product)
                and UnderlierForProduct(UnderlierForProduct(product)) -> index exists)
        then UnderlierForProduct(UnderlierForProduct(product)) -> index -> productIdentifier
            then extract GetProductIdentifierFilteringISIN

func GetAllUnderlierProductIdentifier: <"Extracts the product identifiers from the product underlier.">
    inputs:
        product Product (1..1)
    output:
        productId ProductIdentifier (0..*)

    add productId:
        if EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
        else if EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation exists
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
            then flatten

    add productId:
        if UnderlierForProduct(product) exists
        then UnderlierForProduct(product)
        else if EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier exists
        then EconomicTermsForProduct(product) -> payout -> performancePayout -> underlier
            then extract
                if security exists
                then security -> productIdentifier
                else if loan exists
                then loan -> productIdentifier
                else if index exists
                then index -> productIdentifier
                else if commodity exists and IsProductETD(product)
                then commodity -> productIdentifier
            then flatten

    add productId:
        if (IsProductETD(product)
                and UnderlierForProduct(product) -> commodity -> productIdentifier exists)
        then UnderlierForProduct(product) -> commodity -> productIdentifier
        else if (IsProductETD(product)
                and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier exists
                and IsSingleCommodityPayoutProduct(product) = False)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
        // swaptions
        else if UnderlierForProduct(product) -> contractualProduct -> productIdentifier exists
        then UnderlierForProduct(product) -> contractualProduct -> productIdentifier
        // IR on bond
        else if EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond exists
        then EconomicTermsForProduct(product) -> payout -> interestRatePayout -> bondReference -> bond
        // FRA on Commodity
        else if EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> commodity exists
        then EconomicTermsForProduct(product) -> payout -> forwardPayout -> underlier -> commodity -> productIdentifier
        // Commodities Index: only for ETDs
        else if (IsProductETD(product)
                and EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index exists
                and IsSingleCommodityPayoutProduct(product) = False)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> index -> productIdentifier
        // ETD Option on Futures on Index
        else if (IsProductETD(product)
                and UnderlierForProduct(UnderlierForProduct(product)) -> index exists)
        then UnderlierForProduct(UnderlierForProduct(product)) -> index -> productIdentifier

func FilterResetHistoryByLeg: <"Extracts the reset history belonging to a leg by filtering the observations of the reset history's product identifier that match with the leg's product identifier.">
    inputs:
        reportableEvent ReportableEvent (1..1)
        payoutLeg PayoutLegWithAuxiliary (1..1)
    output:
        resetHistory Reset (0..*)

    add resetHistory:
        if TradeStateForEvent(reportableEvent) -> resetHistory -> observations -> observationIdentifier -> observable -> rateOption exists
        then TradeStateForEvent(reportableEvent) -> resetHistory
            filter
                (observations -> observationIdentifier -> observable -> rateOption -> floatingRateIndex any = payoutLeg -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex
                    or observations -> observationIdentifier -> observable -> rateOption -> inflationRateIndex any = payoutLeg -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> inflationRateIndex)
        else if TradeStateForEvent(reportableEvent) -> resetHistory -> observations -> observationIdentifier -> observable -> commodity -> productIdentifier exists
        then TradeStateForEvent(reportableEvent) -> resetHistory
            filter
                observations -> observationIdentifier -> observable -> commodity -> productIdentifier -> identifier = payoutLeg -> commodityPayout -> underlier -> commodity -> productIdentifier -> identifier

func GetLastFloatingReferenceResetDate: <"Extracts the last reset date filtering by the current date.">
    inputs:
        resetHistory Reset (1..*)
    output:
        lastFloatingReferenceResetDate date (0..1)

    set lastFloatingReferenceResetDate:
        resetHistory
            filter resetDate <= Today
            then resetDate
            then max

func GetLastFloatingReferenceValue: <"Extracts the last reset value filtering by the current date.">
    inputs:
        resetHistory Reset (1..*)
    output:
        lastFloatingReferenceValue number (0..1)

    set lastFloatingReferenceValue:
        resetHistory
            filter item -> resetDate <= Today
            then max [ item -> resetDate ]
            then item -> resetValue -> value

func GetNextFloatingReferenceResetDate:
    inputs:
        reportableEvent ReportableEvent (1..1)
        interestRateLeg InterestRatePayout (1..1)
    output:
        nextFloatingReferenceResetDate date (0..1)

    set nextFloatingReferenceResetDate:
        ProductForEvent(reportableEvent)
            then filter IsFRA = False
            then extract ProductOrUnderlierProduct
            then extract interestRateLeg
            then extract
                if rateSpecification -> floatingRate exists and resetDates exists
                then resetDates -> fixingDates -> adjustedDate
                else if rateSpecification -> inflationRate exists and resetDates exists
                then resetDates -> fixingDates -> adjustedDate

func ExtractReferenceEntity: <"For Credit Default Swaps or Credit Swaptions, extracts the reference entity that contains an LEI or CountryCode entityId, or if neither exists, returns any reference entity id.">
    inputs:
        reportableEvent ReportableEvent (0..1)
    output:
        referenceEntity string (0..1)

    alias product: ProductForEvent(reportableEvent)

    alias referenceEntityProduct:
        if IsCreditSwaption(product)
        then UnderlierForProduct(product) -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceEntity
        else if IsCreditDefaultSwap(product)
        then product -> contractualProduct -> economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceEntity

    alias referenceEntityByScheme:
        referenceEntityProduct -> entityId
            then filter
                (StringContains(
                        item -> scheme,
                        "http://www.fpml.org/coding-scheme/external/iso17442"
                    ) // LEI
                    or StringContains(
                            item -> scheme,
                            "http://www.fpml.org/coding-scheme/external/iso3166"
                        )) // CountryCode
            then first

    set referenceEntity:
        if referenceEntityByScheme exists and referenceEntityByScheme <> ""
        then referenceEntityByScheme
        else referenceEntityProduct -> entityId
            then last

func FormatToShortFraction5DecimalNumber: <"Rounds the number to fit within 25 digits, including up to 5 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber ShortFraction5DecimalNumber (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 9999999999999999999999999
        then (RoundToPrecisionRemoveTrailingZeros(
                inputNumber,
                5,
                RoundingDirectionEnum -> Nearest
            )
            then RoundToSignificantFigures(item, 25, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToNonNegativeShortFraction5DecimalNumber: <"Sets the output type as a non-negative number, and rounds the number to fit within 25 digits, including up to 5 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber NonNegativeShortFraction5DecimalNumber (1..1)
    set formattedNumber: <"The function handles the formatting while the output type handles the non-negativity check.">
        FormatToShortFraction5DecimalNumber(inputNumber)

func FormatToMax3Number: <"Rounds the number to fit within 3 digits, with no decimals. If the length of the integer part exceeds the allowed limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 99999
        then (RoundToPrecisionRemoveTrailingZeros(
                inputNumber,
                0,
                RoundingDirectionEnum -> Nearest
            )
            then RoundToSignificantFigures(item, 3, RoundingDirectionEnum -> Nearest))
        else inputNumber

func FormatToLongFraction20DecimalNumber: <"Rounds the number to fit within 20 digits, including up to 19 decimals. If the length of the integer part exceeds the allowed digit limit, the original value is returned without alteration.">
    inputs:
        inputNumber number (1..1)
    output:
        formattedNumber number (1..1)
    set formattedNumber:
        if Abs(inputNumber) <= 99999999999999999999
        then (RoundToPrecisionRemoveTrailingZeros(
                inputNumber,
                19,
                RoundingDirectionEnum -> Nearest
            )
            then RoundToSignificantFigures(item, 20, RoundingDirectionEnum -> Nearest))
        else inputNumber

func ExtractCommodityClassification: <"Extracts a commodity classification value from the product taxonomy of the commodity underlier, filtered by taxonomy source and ordinal.">
    inputs:
        economicTerms EconomicTerms (1..1)
        taxonomySource TaxonomySourceEnum (1..1)
        ordinal int (1..1)
    output:
        commodityClassification string (0..1)

    alias commodityUnderlier:
        if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then economicTerms -> payout -> commodityPayout first -> underlier -> commodity
        else if Qualify_Commodity_Option(economicTerms)
        then economicTerms -> payout -> optionPayout only-element -> underlier -> commodity
        else if Qualify_Commodity_Swaption(economicTerms)
        then EconomicTermsForProduct(
                    economicTerms -> payout -> optionPayout only-element -> underlier
                ) -> payout -> commodityPayout first -> underlier -> commodity
        else if Qualify_Commodity_Forward(economicTerms)
        then economicTerms -> payout -> forwardPayout only-element -> underlier -> commodity
        else economicTerms -> payout -> commodityPayout only-element -> underlier -> commodity

    alias taxonomy:
        commodityUnderlier -> productTaxonomy filter item -> source = taxonomySource

    set commodityClassification:
        taxonomy only-element -> value -> classification
            filter item -> ordinal = ordinal
            then only-element -> value

func ExtractCommodityClassificationLeg1: <"Extracts leg 1 commodity classification value from the product taxonomy of the commodity underlier, filtered by taxonomy source and ordinal.">
    inputs:
        product Product (1..1)
        taxonomySource TaxonomySourceEnum (1..1)
        ordinal int (1..1)
    output:
        commodityClassification string (0..1)

    alias commodityUnderlier:
        if Qualify_Commodity_Option(EconomicTermsForProduct(product))
        then UnderlierForProduct(product) -> commodity
        else if IsCommoditySwaption(product)
                and CommodityLeg1(UnderlierForProduct(product)) -> underlier -> commodity exists
        then CommodityLeg1(UnderlierForProduct(product)) -> underlier -> commodity
        else if IsCommoditySwap(product)
                and CommodityLeg1(product) -> underlier -> commodity exists
        then CommodityLeg1(product) -> underlier -> commodity
        else if IsCommodityFloatingPriceForward(product)
        then EconomicTermsForProduct(product) -> payout -> commodityPayout only-element -> underlier -> commodity

    alias taxonomy:
        commodityUnderlier -> productTaxonomy filter item -> source = taxonomySource

    set commodityClassification:
        taxonomy only-element -> value -> classification
            filter item -> ordinal = ordinal
            then only-element -> value

func ExtractCommodityClassificationLeg2: <"Extracts leg 2 commodity classification value from the product taxonomy of the commodity underlier, filtered by taxonomy source and ordinal.">
    inputs:
        product Product (1..1)
        taxonomySource TaxonomySourceEnum (1..1)
        ordinal int (1..1)
    output:
        commodityClassification string (0..1)

    alias commodityUnderlier:
        if IsCommoditySwaption(product)
                and CommodityLeg2(UnderlierForProduct(product)) -> underlier -> commodity exists
        then CommodityLeg2(UnderlierForProduct(product)) -> underlier -> commodity
        else if IsCommoditySwap(product)
                and CommodityLeg2(product) -> underlier -> commodity exists
        then CommodityLeg2(product) -> underlier -> commodity
        else if Qualify_Commodity_Forward(EconomicTermsForProduct(product)) // Description of the commodity delivered is found within the forwardPayout
        then EconomicTermsForProduct(product) -> payout -> forwardPayout only-element -> underlier -> commodity

    alias taxonomy:
        commodityUnderlier -> productTaxonomy filter item -> source = taxonomySource

    set commodityClassification:
        taxonomy only-element -> value -> classification
            filter item -> ordinal = ordinal
            then only-element -> value

func IsCreditTotalReturnSwap: <"Evaluates a product as Credit Total Return Swap when the product qualifies a product as a Credit based on the economic terms and the following criteria: 1) A product with one performance leg and one interest leg, 2) the underlier is either a loan, a security or index">
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    alias performanceUnderlier:
        EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier

    set result:
        Qualify_AssetClass_Credit(EconomicTermsForProduct(product)) = True
            and ((EconomicTermsForProduct(product) -> payout -> interestRatePayout exists
                and EconomicTermsForProduct(product) -> payout -> performancePayout exists)
                and if performanceUnderlier exists
                    then (performanceUnderlier -> loan exists
                            or performanceUnderlier -> security -> securityType = SecurityTypeEnum -> Debt
                            or performanceUnderlier -> index exists))

func IsEquityOther: <"Evaluates a product as Equity Other product when it is either qualifies as Equity Option (Other) or Equity Swap (Other)">
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)
    set result:
        Qualify_Equity_OtherOption(EconomicTermsForProduct(product)) = True
            or Qualify_Equity_OtherSwap(EconomicTermsForProduct(product)) = True

func AdjustPeriod:
    inputs:
        period FrequencyPeriodEnum (0..1)
        periodMultiplier number (0..1)
    output:
        periodValue FrequencyPeriodEnum (0..1)
    set periodValue:
        if period = FrequencyPeriodEnum -> MNTH and periodMultiplier = 12
        then FrequencyPeriodEnum -> YEAR
        else period

func AdjustPeriodMultiplier:
    inputs:
        period FrequencyPeriodEnum (0..1)
        periodMultiplier number (0..1)
    output:
        periodMultiplierValue number (0..1)
    set periodMultiplierValue:
        if period = FrequencyPeriodEnum -> MNTH and periodMultiplier = 12
        then 1
        else periodMultiplier

func GetTransactionInformationForRegime:
    inputs:
        reportableEvent ReportableEvent (0..1)
        regime RegimeNameEnum (0..1)
        supervisoryBodyIn SupervisoryBodyEnum (0..1)
    output:
        transactionInformation TransactionInformation (0..1)

    set transactionInformation:
        reportableEvent -> reportableInformation -> transactionInformation
            then filter
                regimeName = regime
                    and (supervisoryBody = supervisoryBodyIn or supervisoryBodyIn is absent)
            then only-element

func GetIsin:
    inputs:
        product Product (0..1)
    output:
        isin string (0..1)

    set isin:
        product
            then extract [
                [contractualProduct -> productIdentifier, security -> productIdentifier]
                    filter source = ProductIdTypeEnum -> ISIN
                    then only-element
                    then extract identifier
            ]

func GetInstrumentType: <"Extracts the Instrument Type attribute from ANNA DSB record template depending on the product.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        instrumentType upi.AnnaDsbInstrumentTypeEnum (0..1)

    alias product: ProductForEvent(reportableEvent)

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias isdaTaxonomy:
        product -> contractualProduct -> productTaxonomy
            filter source = TaxonomySourceEnum -> ISDA and value -> name exists
            then first
            then value -> name

    alias isOption: IsOption(product)

    set instrumentType:
        if isOption
                or Qualify_InterestRate_CapFloor(economicTerms)
                or Qualify_CreditDefaultSwaption(economicTerms)
        then upi.AnnaDsbInstrumentTypeEnum -> Option
        else if Qualify_ForeignExchange_Swap(economicTerms)
                or Qualify_ForeignExchange_NDS(economicTerms)
                or Qualify_BaseProduct_EquitySwap(economicTerms)
                or Qualify_BaseProduct_IRSwap(economicTerms)
                or Qualify_BaseProduct_CrossCurrency(economicTerms)
                or Qualify_BaseProduct_Inflation(economicTerms)
                or Qualify_CreditDefaultSwap_SingleName(economicTerms)
                or Qualify_CreditDefaultSwap_Basket(economicTerms)
                or Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
                or Qualify_CreditDefaultSwap_Loan(economicTerms)
                or (IsCreditTotalReturnSwap(product) or StringContains(isdaTaxonomy, "^Credit:TotalReturnSwap.*"))
                or IsCommoditySwap(product)
                or Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
                or IsEquitySwapProduct(product)
                or IsDividendSwap(product)
                or (IsVarianceSwap(product)
                    and Qualify_ForeignExchange_ParameterReturnVariance(economicTerms) = False)
                or (IsVolatilitySwap(product)
                    and Qualify_ForeignExchange_ParameterReturnVolatility(economicTerms) = False)
                or Qualify_EquitySwap_TotalReturnBasicPerformance_Basket(economicTerms)
                or Qualify_EquitySwap_TotalReturnBasicPerformance_Index(economicTerms)
                or Qualify_EquitySwap_TotalReturnBasicPerformance_SingleName(economicTerms)
                or Qualify_EquitySwap_PriceReturnBasicPerformance_Basket(economicTerms)
                or Qualify_EquitySwap_PriceReturnBasicPerformance_Index(economicTerms)
                or Qualify_EquitySwap_PriceReturnBasicPerformance_SingleName(economicTerms)
        then upi.AnnaDsbInstrumentTypeEnum -> Swap
        else if Qualify_BaseProduct_Fra(economicTerms)
                or Qualify_InterestRate_Forward_Debt(economicTerms)
                or IsFXForward(product)
                or Qualify_ForeignExchange_NDF(economicTerms)
                or Qualify_ForeignExchange_Spot_Forward(economicTerms)
                or Qualify_Commodity_Forward(economicTerms)
                or isdaTaxonomy = "InterestRate:Forward:Debt"
                or IsEquityForward(product)
                or Qualify_EquityForward_PriceReturnBasicPerformance_Basket(economicTerms)
                or Qualify_EquityForward_PriceReturnBasicPerformance_SingleIndex(
                        economicTerms
                    )
                or Qualify_EquityForward_PriceReturnBasicPerformance_SingleName(
                        economicTerms
                    )
        then upi.AnnaDsbInstrumentTypeEnum -> Forward
        else upi.AnnaDsbInstrumentTypeEnum -> Other

func IsNotionalScheduleCustom: <"Identifies if the Notional Schedule attribute from ANNA DSB record template is Constant or Custom.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result upi.AnnaDsbNotionalScheduleEnum (0..1)

    alias product: ProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(product)

    alias leg1:
        Qualify_BaseProduct_IRSwap(economicTerms)
            or Qualify_BaseProduct_Inflation(economicTerms)
            or Qualify_BaseProduct_CrossCurrency(economicTerms)
            then Compute_NotionalScheduleType(
                        GetLeg1ResolvablePriceQuantity(TradeForEvent(reportableEvent)) -> quantitySchedule -> datedValue -> value
                    )

    alias leg2:
        Qualify_BaseProduct_IRSwap(economicTerms)
            or Qualify_BaseProduct_Inflation(economicTerms)
            or Qualify_BaseProduct_CrossCurrency(economicTerms)
            then Compute_NotionalScheduleType(
                        GetLeg2ResolvablePriceQuantity(TradeForEvent(reportableEvent)) -> quantitySchedule -> datedValue -> value
                    )
    set result:
        if Qualify_BaseProduct_IRSwap(economicTerms)
                or Qualify_BaseProduct_Inflation(economicTerms)
                or Qualify_BaseProduct_CrossCurrency(economicTerms)
        then (if IsOption(product)
            then empty
            else if leg1 = leg2
            then leg1
            else upi.AnnaDsbNotionalScheduleEnum -> Custom)

func IsUnderlyingAssetTypeFixedFixed: <"Identifies if the Underlying Asset Type attribute from ANNA DSB record template is Fixed-Fixed.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result boolean (0..1)

    alias product: ProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(product)

    set result:
        Qualify_InterestRate_CrossCurrency_FixedFixed(economicTerms)
            or Qualify_InterestRate_IRSwap_FixedFixed(economicTerms)

func IsUnderlyingAssetTypeIndex: <"Identifies if the Underlying Asset Type attribute from ANNA DSB record template is Index.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result boolean (0..1)

    alias product: ProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(product)

    set result:
        Qualify_CreditDefaultSwap_Index(economicTerms)
            or IsCreditTotalReturnSwap(product)
            or Qualify_InterestRate_IRSwap_FixedFixed(economicTerms)
            or IsCommoditySwap(product)
            or IsCommodityForward(product)
            or IsCommodityOption(product)
            or IsCommoditySwaption(product)
            or Qualify_EquitySwap_ParameterReturnDividend_Index(economicTerms)
            or Qualify_EquitySwap_ParameterReturnVariance_Index(economicTerms)
            or Qualify_EquitySwap_ParameterReturnVolatility_Index(economicTerms)
            or Qualify_EquitySwap_TotalReturnBasicPerformance_Index(economicTerms)
            or Qualify_EquitySwap_PriceReturnBasicPerformance_Index(economicTerms)
            or Qualify_EquityForward_PriceReturnBasicPerformance_SingleIndex(economicTerms)
            or Qualify_BaseProduct_EquitySwap(economicTerms)
            or Qualify_EquityOption_PriceReturnBasicPerformance_Index(economicTerms)

func IsReturnorPayoutTriggerCFD: <"Identifies if the Return or Payout Trigger attribute from ANNA DSB record template is Contract for Difference.">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        result boolean (0..1)

    alias product: ProductForEvent(reportableEvent)
    alias economicTerms: EconomicTermsForProduct(product)

    set result:
        Qualify_Commodity_Swap_Basis(economicTerms)
            or IsCommoditySwap(product)
            or IsEquitySwapProduct(product)

func IsCommodityMetal:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    alias productIdentifier:
        product -> contractualProduct -> productIdentifier
            then filter
                identifier -> scheme = "http://www.fpml.org/coding-scheme/product-taxonomy"
            then only-element
            then extract identifier

    alias productTaxonomy:
        product -> contractualProduct -> productTaxonomy
            then filter source = TaxonomySourceEnum -> ISDA
            then only-element
            then extract value -> name

    alias productClass:
        if productTaxonomy exists and productIdentifier exists
        then [productTaxonomy, productIdentifier] distinct only-element
        else if productTaxonomy exists
        then productTaxonomy
        else if productIdentifier exists
        then productIdentifier

    alias commodityReferencePrice:
        [
            UnderlierForProduct(product) -> commodity -> productIdentifier
                then filter source = ProductIdTypeEnum -> ISDACRP
                then only-element
                then extract identifier,
            EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
                then filter source = ProductIdTypeEnum -> ISDACRP
                then only-element
                then extract identifier
        ]
            only-element

    set result:
        if productClass exists and commodityReferencePrice exists
        then StringContains(productClass, "Metals:NonPrecious")
                and IsCRPMetal(commodityReferencePrice)
        else if productClass exists and StringContains(productClass, "Metals:NonPrecious")
        then True
        else if commodityReferencePrice exists and IsCRPMetal(commodityReferencePrice)
        then True
        else False

func IsCommodityBullion:
    inputs:
        product Product (1..1)
    output:
        result boolean (1..1)

    alias productIdentifier: // DRR
        product -> contractualProduct -> productIdentifier
            then filter
                identifier -> scheme = "http://www.fpml.org/coding-scheme/product-taxonomy"
            then only-element
            then extract identifier

    alias productTaxonomy: // BNPP
        product -> contractualProduct -> productTaxonomy
            then filter source = TaxonomySourceEnum -> ISDA
            then only-element
            then extract value -> name

    alias productClass:
        if productTaxonomy exists and productIdentifier exists
        then [productTaxonomy, productIdentifier] distinct only-element
        else if productTaxonomy exists
        then productTaxonomy
        else if productIdentifier exists
        then productIdentifier

    alias commodityReferencePrice:
        [
            UnderlierForProduct(product) -> commodity -> productIdentifier
                then filter source = ProductIdTypeEnum -> ISDACRP
                then only-element
                then extract identifier,
            EconomicTermsForProduct(product) -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
                then filter source = ProductIdTypeEnum -> ISDACRP
                then only-element
                then extract identifier
        ]
            only-element

    set result:
        if productClass exists and commodityReferencePrice exists
        then StringContains(productClass, "Metals:Precious")
                and IsCRPBullion(commodityReferencePrice)
        else if productClass exists and StringContains(productClass, "Metals:Precious")
        then True
        else if commodityReferencePrice exists and IsCRPBullion(commodityReferencePrice)
        then True
        else False

func IsCRPMetal:
    inputs:
        identifier string (1..1)
    output:
        result boolean (1..1)
    set result:
        StringContains(identifier, "ALUMINIUM-")
            or StringContains(identifier, "COPPER-")
            or StringContains(identifier, "IRON ORE-")
            or StringContains(identifier, "LEAD-")
            or StringContains(identifier, "NASAAC-")
            or StringContains(identifier, "NICKEL-")
            or StringContains(identifier, "STEEL-")
            or StringContains(identifier, "TIN-")
            or StringContains(identifier, "ZINC-")

func IsCRPBullion:
    inputs:
        identifier string (1..1)
    output:
        result boolean (1..1)
    set result:
        StringContains(identifier, "GOLD-")
            or StringContains(identifier, "PALLADIUM-")
            or StringContains(identifier, "PLATINUM-")
            or StringContains(identifier, "SILVER-")

func ExtractNatureOfCounterparty: <"Converts a NatureOfPartyEnum value into the corresponding NatureOfCounterpartyEnum value">
    inputs:
        natureOfParty NatureOfPartyEnum (1..1)
    output:
        natureOfCounterparty party.NatureOfCounterpartyEnum (1..1)
    set natureOfCounterparty:
        if natureOfParty = NatureOfPartyEnum -> Financial
        then party.NatureOfCounterpartyEnum -> F
        else if natureOfParty = NatureOfPartyEnum -> NonFinancial
        then N
        else if natureOfParty = NatureOfPartyEnum -> CentralCounterparty
        then C
        else if natureOfParty = NatureOfPartyEnum -> Exempt
        then O
