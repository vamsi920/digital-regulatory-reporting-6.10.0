namespace drr.enrichment.upi
version "${project.version}"

import cdm.base.datetime.*
import cdm.base.staticdata.asset.common.*
import cdm.base.staticdata.asset.rates.*
import cdm.base.staticdata.party.*
import cdm.event.common.*
import cdm.event.workflow.*
import cdm.product.asset.*
import cdm.product.common.settlement.*
import cdm.product.qualification.*
import cdm.product.template.*

import drr.enrichment.upi.*
import drr.regulation.common.*
import drr.regulation.common.util.*
import drr.standards.iosco.cde.base.* as cde
import drr.standards.iosco.upi.*
import drr.standards.iosco.upi.codesets.*

func API_AnnaDsbRetrieveUpi:
    [codeImplementation]
    inputs:
        request AnnaDsbUpiRequest (1..1)
    output:
        response AnnaDsbUpiRecord (0..1)

func Create_AnnaDsbUpiRequestFromReportableEvent:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        request AnnaDsbUpiRequestAndType (0..1)

    alias product: ProductForTrade(TradeForEvent(reportableEvent))

    alias isSwaption: product then (IsCreditSwaption or IsIRSwaption)

    alias underlyingRequestNeeded:
        isSwaption and (product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> underlier -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> UPI
            then is absent
            )

    set request -> requestType:
        if underlyingRequestNeeded
        then AnnaDsbUpiRequestTypeEnum -> UnderlyingProductRequest
        else AnnaDsbUpiRequestTypeEnum -> ProductRequest

    set request -> request:
        Create_AnnaDsbUpiRequestFromReportableEventAndUnderlying(reportableEvent)

func Enrich_ReportableEventWithUpi: <"Uses CDM description of the product to query Anna DSB for a UPI, then enriches the CDM">
    inputs:
        reportableEvent ReportableEvent (1..1)
        upiRecord AnnaDsbUpiRecord (1..1)
    output:
        reportableEventWithUpi ReportableEvent (1..1)

    set reportableEventWithUpi:
        Enrich_ReportableEventWithUpiFromAnnaDsb(reportableEvent, upiRecord, empty)

func Existing_Upi: <"Used in Java to extract pre-existing value from upstream">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        existingUpi string (1..1)

    alias product: ProductForEvent(reportableEvent)

    set existingUpi:
        product -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> UPI
            then only-element
            then identifier

func Existing_OtcIsin: <"Used in Java to extract pre-existing value from upstream">
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        existingIsin string (1..1)

    alias product: ProductForEvent(reportableEvent)

    set existingIsin:
        product -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then only-element
            then identifier

func Enrich_ReportableEventWithUpiFromAnnaDsb: <"Used in Java to enrich CDM with Anna DSB UPI">
    inputs:
        reportableEvent ReportableEvent (1..1)
        upiRecord AnnaDsbUpiRecord (0..1)
        underlyingUpiRecord AnnaDsbUpiRecord (0..1) // swaption
    output:
        reportableEventWithUpi ReportableEvent (1..1)

    alias existingUpi: ExtractUpi(reportableEvent)
    alias existingCfi:
        ProductForEvent(reportableEvent) -> contractualProduct -> productTaxonomy
            filter source = TaxonomySourceEnum -> CFI
    alias existingUnderlyingUpi:
        ProductForEvent(reportableEvent) -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> underlier -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> UPI
            then only-element

    set reportableEventWithUpi: reportableEvent

    add reportableEventWithUpi -> reportableInformation -> enrichment -> upiData:
        if upiRecord exists
        then UpiData {
                upiRecord: upiRecord,
                upiOfUnderlying: False,
                upiValidation: True
            }

    add reportableEventWithUpi -> reportableInformation -> enrichment -> upiData:
        if underlyingUpiRecord exists
        then UpiData {
                upiRecord: underlyingUpiRecord,
                upiOfUnderlying: True,
                upiValidation: True
            }

    add reportableEventWithUpi -> originatingWorkflowStep -> businessEvent -> after -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> productIdentifier:
        if underlyingUpiRecord exists and existingUnderlyingUpi is absent
        then ProductIdentifier {
                identifier: upiRecord -> Identifier -> UPI,
                source: ProductIdTypeEnum -> UPI
            }

    add reportableEventWithUpi -> originatingWorkflowStep -> businessEvent -> after -> trade -> tradableProduct -> product -> contractualProduct -> productIdentifier:
        if upiRecord exists and existingUpi is absent
        then ProductIdentifier {
                identifier: upiRecord -> Identifier -> UPI,
                source: ProductIdTypeEnum -> UPI
            }

    add reportableEventWithUpi -> originatingWorkflowStep -> businessEvent -> after -> trade -> tradableProduct -> product -> contractualProduct -> productTaxonomy:
        if upiRecord exists
                and upiRecord -> Derived -> ClassificationType exists
                and existingCfi is absent
        then ProductTaxonomy {
                value: TaxonomyValue {
                    name: upiRecord -> Derived -> ClassificationType,
                    ...
                },
                source: TaxonomySourceEnum -> CFI,
                ...
            }

func EnrichReportableEventWithUpiForSwaption:
    inputs:
        reportableEvent ReportableEvent (1..1)
        upi string (0..1)
    output:
        enrichedReportableEvent ReportableEvent (1..1)

    alias addProductIdentifier:
        ProductIdentifier {
            identifier: upi,
            source: ProductIdTypeEnum -> UPI
        }

    set enrichedReportableEvent: reportableEvent

    add enrichedReportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> productIdentifier:
        addProductIdentifier

    add enrichedReportableEvent -> originatingWorkflowStep -> businessEvent -> after -> trade -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout -> underlier -> contractualProduct -> productIdentifier:
        addProductIdentifier

func Create_AnnaDsbUpiRequest:
    inputs:
        originatingWorkflowStep WorkflowStep (1..1)
        reportableInformation ReportableInformation (1..1)
        reportableTrade TradeState (0..1)
    output:
        request AnnaDsbUpiRequest (0..1)

    alias needToRequestUpi:
        ProductForTrade(
                TradeForEvent(
                        ReportableEvent {
                            originatingWorkflowStep: originatingWorkflowStep,
                            reportableInformation: reportableInformation,
                            reportableTrade: reportableTrade,
                            reportablePosition: empty
                        }
                    )
            ) -> contractualProduct
            then productIdentifier -> source all <> ProductIdTypeEnum -> ISIN

    set request: // if needToRequestUpi then 
        Create_AnnaDsbUpiRequestFromReportableEventAndUnderlying(
                ReportableEvent {
                    originatingWorkflowStep: originatingWorkflowStep,
                    reportableInformation: reportableInformation,
                    reportableTrade: reportableTrade,
                    reportablePosition: empty
                }
            )

func Create_AnnaDsbUpiRequestFromReportableEventAndUnderlying:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        request AnnaDsbUpiRequest (0..1)

    alias tradeForEvent:
        if reportableEvent -> reportableTrade exists
        then reportableEvent -> reportableTrade -> trade
        else reportableEvent -> originatingWorkflowStep -> businessEvent -> after -> trade only-element

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias isdaTaxonomy:
        product -> contractualProduct -> productTaxonomy
            filter source = TaxonomySourceEnum -> ISDA and value -> name exists
            then first
            then value -> name

    alias isSwaption:
        IsCreditSwaption(tradeForEvent -> tradableProduct -> product)
            or IsIRSwaption(tradeForEvent -> tradableProduct -> product)

    alias product:
        if isSwaption
        then ( // If no Underying UPI present, we need to create UPI request for Underlier
            if (tradeForEvent -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> underlier -> contractualProduct -> productIdentifier
                filter source = ProductIdTypeEnum -> UPI
                then is absent)
            then tradeForEvent -> tradableProduct -> product -> contractualProduct -> economicTerms -> payout -> optionPayout only-element -> underlier
            else tradeForEvent -> tradableProduct -> product // Case of Swaption with already existing underlying UPI
            )
        else tradeForEvent -> tradableProduct -> product // Not a swaption (no need for underlying UPI)
    alias isOption: IsOption(product)

    alias useCase:
        if isdaTaxonomy = "ForeignExchange:SimpleExotic:Digital"
        then AnnaDsbUseCaseEnum -> Digital_Option
        else if isdaTaxonomy = "ForeignExchange:SimpleExotic:Barrier"
        then AnnaDsbUseCaseEnum -> Barrier_Option
        else if isdaTaxonomy = "ForeignExchange:NDO"
        then AnnaDsbUseCaseEnum -> NDO
        else if isdaTaxonomy = "ForeignExchange:ComplexExotic"
        then AnnaDsbUseCaseEnum -> Non_Standard
        else if Qualify_ForeignExchange_VanillaOption(economicTerms)
        then AnnaDsbUseCaseEnum -> Vanilla_Option
        else if Qualify_ForeignExchange_Spot_Forward(economicTerms)
        then AnnaDsbUseCaseEnum -> Forward
        else if Qualify_ForeignExchange_Swap(economicTerms)
        then AnnaDsbUseCaseEnum -> FX_Swap
        else if Qualify_ForeignExchange_NDS(economicTerms)
        then AnnaDsbUseCaseEnum -> Non_Deliverable_FX_Swap
        else if Qualify_ForeignExchange_NDF(economicTerms)
        then AnnaDsbUseCaseEnum -> NDF
        else if isdaTaxonomy = "InterestRate:Exotic"
        then AnnaDsbUseCaseEnum -> Non_Standard
        else if isdaTaxonomy = "InterestRate:Forward:Debt"
        then AnnaDsbUseCaseEnum -> Debt
        else if isdaTaxonomy = "InterestRate:FRA"
        then AnnaDsbUseCaseEnum -> FRA_Index
        else if Qualify_InterestRate_IRSwap_FixedFloat(economicTerms)
        then AnnaDsbUseCaseEnum -> Fixed_Float
        else if Qualify_InterestRate_IRSwap_FixedFixed(economicTerms)
        then AnnaDsbUseCaseEnum -> Fixed_Fixed
        else if Qualify_InterestRate_InflationSwap_FixedFloat_YearOn_Year(economicTerms)
        then AnnaDsbUseCaseEnum -> Inflation_Fixed_Float_YoY
        else if Qualify_InterestRate_InflationSwap_FixedFloat_ZeroCoupon(economicTerms)
        then AnnaDsbUseCaseEnum -> Inflation_Fixed_Float_Zero_Coupon
        else if Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(economicTerms)
        then AnnaDsbUseCaseEnum -> Inflation_Basis_YoY
        else if Qualify_InterestRate_InflationSwap_Basis_ZeroCoupon(economicTerms)
        then AnnaDsbUseCaseEnum -> Inflation_Basis_Zero_Coupon
        else if Qualify_BaseProduct_Inflation(economicTerms)
        then AnnaDsbUseCaseEnum -> Inflation_Swap
        else if Qualify_InterestRate_CrossCurrency_FixedFixed(economicTerms)
        then AnnaDsbUseCaseEnum -> Cross_Currency_Fixed_Fixed
        else if Qualify_InterestRate_CrossCurrency_FixedFloat(economicTerms)
        then AnnaDsbUseCaseEnum -> Cross_Currency_Fixed_Float
        else if Qualify_InterestRate_IRSwap_Basis(economicTerms)
        then AnnaDsbUseCaseEnum -> Basis
        else if Qualify_InterestRate_IRSwap_Basis_OIS(economicTerms)
        then AnnaDsbUseCaseEnum -> Basis_OIS
        else if Qualify_InterestRate_IRSwap_FixedFloat_ZeroCoupon(economicTerms)
        then AnnaDsbUseCaseEnum -> Fixed_Float_Zero_Coupon
        else if Qualify_InterestRate_IRSwap_FixedFloat_OIS(economicTerms)
        then AnnaDsbUseCaseEnum -> Fixed_Float_OIS
        else if Qualify_InterestRate_CrossCurrency_Basis(economicTerms)
        then AnnaDsbUseCaseEnum -> Cross_Currency_Basis
        else if Qualify_InterestRate_Option_Swaption(economicTerms)
        then AnnaDsbUseCaseEnum -> Swaption
        else if Qualify_InterestRate_CapFloor(economicTerms)
        then AnnaDsbUseCaseEnum -> CapFloor
        else if Qualify_InterestRate_Option_DebtOption(economicTerms)
        then AnnaDsbUseCaseEnum -> Debt_Option
        else if Qualify_CreditDefaultSwap_Loan(economicTerms)
        then AnnaDsbUseCaseEnum -> Loan
        else if Qualify_CreditDefaultSwap_Index(economicTerms)
        then AnnaDsbUseCaseEnum -> Index
        else if Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
        then AnnaDsbUseCaseEnum -> Index_Tranche
        else if Qualify_CreditDefaultSwaption(economicTerms)
        then (if Qualify_CreditDefaultSwap_SingleName(
                        UnderlierForProduct(product) -> contractualProduct -> economicTerms
                    )
            then AnnaDsbUseCaseEnum -> Single_Name_Swaption
            else if Qualify_CreditDefaultSwap_Index(
                        UnderlierForProduct(product) -> contractualProduct -> economicTerms
                    )
            then AnnaDsbUseCaseEnum -> Index_Swaption)
        else if StringContains(isdaTaxonomy, "^Credit:SingleName:Corporate:.*")
        then AnnaDsbUseCaseEnum -> Corporate
        else if StringContains(isdaTaxonomy, "^Credit:SingleName:Sovereign:.*")
        then AnnaDsbUseCaseEnum -> Sovereign
        else if StringContains(isdaTaxonomy, "^Credit:SingleName:Muni:.*")
        then AnnaDsbUseCaseEnum -> Municipal
        else if StringContains(isdaTaxonomy, "^Credit:TotalReturnSwap.*")
        then AnnaDsbUseCaseEnum -> Total_Return_Swap
        else if StringContains(isdaTaxonomy, "^Credit:Exotic.*")
        then AnnaDsbUseCaseEnum -> Non_Standard
        else if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then AnnaDsbUseCaseEnum -> Swap
        else if Qualify_Commodity_Swaption(economicTerms)
        then AnnaDsbUseCaseEnum -> Swaption
        else if Qualify_Commodity_Option(economicTerms)
        then AnnaDsbUseCaseEnum -> Option
        else if Qualify_Commodity_Forward(economicTerms)
        then AnnaDsbUseCaseEnum -> Forward

    alias settlementTerms:
        [economicTerms -> payout -> forwardPayout -> settlementTerms, economicTerms -> payout -> optionPayout -> settlementTerms, economicTerms -> payout -> interestRatePayout -> settlementTerms, economicTerms -> payout -> creditDefaultPayout -> settlementTerms]
            first

    alias leg1:
        Qualify_BaseProduct_IRSwap(economicTerms)
            then Compute_NotionalScheduleType(
                        GetLeg1ResolvablePriceQuantity(tradeForEvent) -> quantitySchedule -> datedValue -> value
                    )

    alias leg2:
        Qualify_BaseProduct_IRSwap(economicTerms)
            then Compute_NotionalScheduleType(
                        GetLeg2ResolvablePriceQuantity(tradeForEvent) -> quantitySchedule -> datedValue -> value
                    )

    alias interestRatePayoutFloatingLeg:
        if InterestRateLeg1(product) -> rateSpecification -> floatingRate exists
        then InterestRateLeg1(product)
        else if InterestRateLeg2(product) -> rateSpecification -> floatingRate exists
        then InterestRateLeg2(product)

    alias instrumentType:
        if isOption
                or Qualify_InterestRate_CapFloor(economicTerms)
                or Qualify_CreditDefaultSwaption(economicTerms)
        then AnnaDsbInstrumentTypeEnum -> Option
        else if Qualify_ForeignExchange_Swap(economicTerms)
                or Qualify_ForeignExchange_NDS(economicTerms)
                or Qualify_BaseProduct_EquitySwap(economicTerms)
                or Qualify_BaseProduct_IRSwap(economicTerms)
                or Qualify_BaseProduct_CrossCurrency(economicTerms)
                or Qualify_BaseProduct_Inflation(economicTerms)
                or Qualify_CreditDefaultSwap_SingleName(economicTerms)
                or Qualify_CreditDefaultSwap_Basket(economicTerms)
                or Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
                or useCase = AnnaDsbUseCaseEnum -> Total_Return_Swap
                or Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then AnnaDsbInstrumentTypeEnum -> Swap
        else if Qualify_BaseProduct_Fra(economicTerms)
                or Qualify_ForeignExchange_NDF(economicTerms)
                or Qualify_ForeignExchange_Spot_Forward(economicTerms)
                or Qualify_Commodity_Forward(economicTerms)
                or isdaTaxonomy = "InterestRate:Forward:Debt"
        then AnnaDsbInstrumentTypeEnum -> Forward

    set request -> Header:
        AnnaDsbHeader {
            Level: AnnaDsbLevelEnum -> UPI,
            AssetClass: if product -> contractualProduct -> productTaxonomy -> primaryAssetClass exists
                then TranslateAssetClass(
                        product -> contractualProduct -> productTaxonomy -> primaryAssetClass only-element
                    )
            else if isSwaption
            then TranslateAssetClass(
                        tradeForEvent -> tradableProduct -> product -> contractualProduct -> productTaxonomy -> primaryAssetClass only-element
                    ),
            UseCase: useCase,
            InstrumentType: instrumentType
        }

    // / Setting Attributes values ///
    set request -> Attributes -> OptionExerciseStyle:
        product
            then if IsOption
                then contractualProduct -> economicTerms -> payout -> optionPayout only-element -> exerciseTerms -> optionStyle
                    extract
                        if americanExercise exists
                        then AnnaDsbOptionExerciseStyleEnum -> AMER
                        else if europeanExercise exists
                        then AnnaDsbOptionExerciseStyleEnum -> EURO
                        else if bermudaExercise exists
                        then AnnaDsbOptionExerciseStyleEnum -> BERM

    set request -> Attributes -> OptionType:
        product
            then if contractualProduct -> economicTerms -> payout -> optionPayout -> optionType all = OptionTypeEnum -> Straddle
                then AnnaDsbOptionTypeEnum -> OPTL
                else if IsFloor or IsPutOption
                then AnnaDsbOptionTypeEnum -> PUTO
                else if IsCallOption or IsCap
                then AnnaDsbOptionTypeEnum -> CALL

    set request -> Attributes -> NotionalCurrency:
        (if Qualify_InterestRate_Option_Swaption(
                    product -> contractualProduct -> economicTerms
                )
        then InterestRateLeg1(UnderlierForProduct(product))
        else if Qualify_AssetClass_InterestRate(
                    product -> contractualProduct -> economicTerms
                )
        then InterestRateLeg1(product))
            then if priceQuantity -> quantitySchedule exists
                then ConvertCurrency(priceQuantity -> quantitySchedule -> unit -> currency)
                else if priceQuantity -> quantityReference exists
                then ConvertCurrency(
                            priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
                        )
                else if useCase = AnnaDsbUseCaseEnum -> Debt_Option
                        or useCase = AnnaDsbUseCaseEnum -> Debt
                then ConvertCurrency(
                            tradeForEvent -> tradableProduct -> tradeLot -> priceQuantity -> quantity first -> unit -> currency
                        )

    set request -> Attributes -> OtherNotionalCurrency:
        if Qualify_InterestRate_CrossCurrency_FixedFloat(
                    product -> contractualProduct -> economicTerms
                )
                or Qualify_InterestRate_CrossCurrency_FixedFixed(
                        product -> contractualProduct -> economicTerms
                    )
                or Qualify_InterestRate_CrossCurrency_Basis(
                        product -> contractualProduct -> economicTerms
                    )
        then cde.quantity.InterestRateNotionalCurrency(InterestRateLeg2(product))

    set request -> Attributes -> UnderlierID:
        if IsIRSwaption(product) or IsCreditSwaption(product)
        then (UnderlierForProduct(product) -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> UPI
            then first
            then identifier)
        else if IsFXForward(product) or IsFXOption(product)
        then (FXLeg1(product)
            then if priceQuantity -> quantitySchedule exists
                then ConvertCurrency(priceQuantity -> quantitySchedule -> unit -> currency)
                else if priceQuantity -> quantityReference exists
                then ConvertCurrency(
                            priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
                        ))
        else if Qualify_ForeignExchange_Swap(economicTerms)
                or Qualify_ForeignExchange_NDS(economicTerms)
        then (FXSwapLeg1(product)
            then if priceQuantity -> quantitySchedule exists
                then ConvertCurrency(priceQuantity -> quantitySchedule -> unit -> currency)
                else if priceQuantity -> quantityReference exists
                then ConvertCurrency(
                            priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
                        ))
        else if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
                or Qualify_Commodity_Forward(economicTerms)
        then (if (economicTerms -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
                filter (source = ProductIdTypeEnum -> ISDACRP)
                then first extract item -> identifier exists)
            then (economicTerms -> payout -> commodityPayout -> underlier -> commodity -> productIdentifier
                filter (source = ProductIdTypeEnum -> ISDACRP)
                then first extract item -> identifier)
            else "OTHER")
        else if Qualify_Commodity_Option(economicTerms)
        then (if (economicTerms -> payout -> optionPayout -> underlier -> commodity -> productIdentifier
                filter source = ProductIdTypeEnum -> ISDACRP
                then first extract item -> identifier exists)
            then (economicTerms -> payout -> optionPayout -> underlier -> commodity -> productIdentifier
                filter source = ProductIdTypeEnum -> ISDACRP
                then first extract item -> identifier))
        else if (InterestRateLeg1(product) -> rateSpecification -> floatingRate exists
                and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap
                and useCase <> AnnaDsbUseCaseEnum -> Non_Standard)
        then (InterestRateLeg1(product) then extract FloatingRateIndex)
        else if (InterestRateLeg1(product) -> rateSpecification -> inflationRate exists and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap and useCase <> AnnaDsbUseCaseEnum -> Non_Standard)
        then (InterestRateLeg1(product) then extract InflationRateIndex to-string)
        else if (InterestRateLeg2(product) -> rateSpecification -> floatingRate exists
                and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap
                and useCase <> AnnaDsbUseCaseEnum -> Non_Standard)
        then (InterestRateLeg2(product) then extract FloatingRateIndex)
        else if (InterestRateLeg2(product) -> rateSpecification -> inflationRate exists and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap and useCase <> AnnaDsbUseCaseEnum -> Non_Standard)
        then (InterestRateLeg2(product) then extract InflationRateIndex to-string)
        else if useCase = AnnaDsbUseCaseEnum -> Debt_Option
        then (tradeForEvent -> tradableProduct -> tradeLot -> priceQuantity -> observable -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first extract item -> identifier)

    set request -> Attributes -> UnderlierIDSource:
        if Qualify_AssetClass_InterestRate(product -> contractualProduct -> economicTerms)
                and (InterestRateLeg1(product) -> rateSpecification -> floatingRate exists
                    or InterestRateLeg1(product) -> rateSpecification -> inflationRate exists
                    or InterestRateLeg2(product) -> rateSpecification -> floatingRate exists
                    or InterestRateLeg2(product) -> rateSpecification -> inflationRate exists)
                and useCase <> AnnaDsbUseCaseEnum -> Non_Standard
        then AnnaDsbUnderlierIDSourceEnum -> FPML
        else if IsFXForward(product)
                or IsFXOption(product)
                or Qualify_ForeignExchange_Swap(economicTerms)
                or Qualify_ForeignExchange_NDS(economicTerms)
        then AnnaDsbUnderlierIDSourceEnum -> CCY
        else if Qualify_CreditDefaultSwaption(economicTerms)
                or Qualify_InterestRate_Option_Swaption(economicTerms)
                or useCase = AnnaDsbUseCaseEnum -> Single_Name_Swaption
        then AnnaDsbUnderlierIDSourceEnum -> UPI
        else if Qualify_InterestRate_Option_DebtOption(economicTerms)
        then AnnaDsbUnderlierIDSourceEnum -> ISIN
        else if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
                or Qualify_Commodity_Option(economicTerms)
                or Qualify_Commodity_Forward(economicTerms)
        then AnnaDsbUnderlierIDSourceEnum -> COMM

    set request -> Attributes -> OtherLegUnderlierID:
        if useCase = AnnaDsbUseCaseEnum -> Inflation_Swap
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
        then empty
        else if Qualify_SubProduct_Basis(product -> contractualProduct -> economicTerms)
        then InterestRateLeg2(product)
            then extract FloatingRateIndex

    set request -> Attributes -> OtherUnderlierID:
        if IsFXForward(product) or IsFXOption(product)
        then ConvertCurrency(cde.quantity.FXNotionalCurrency(FXLeg2(product)))
        else if Qualify_ForeignExchange_Swap(economicTerms)
                or Qualify_ForeignExchange_NDS(economicTerms)
        then ConvertCurrency(cde.quantity.FXNotionalCurrency(FXSwapLeg2(product)))

    set request -> Attributes -> OtherUnderlierIDSource:
        if IsFXForward(product)
                or IsFXOption(product)
                or Qualify_ForeignExchange_Swap(economicTerms)
                or Qualify_ForeignExchange_NDS(economicTerms)
        then AnnaDsbOtherUnderlierIDSourceEnum -> CCY

    set request -> Attributes -> OtherLegUnderlierIDSource:
        if useCase = AnnaDsbUseCaseEnum -> Inflation_Swap
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
        then empty
        else if Qualify_SubProduct_Basis(product -> contractualProduct -> economicTerms)
        then AnnaDsbOtherLegUnderlierIDSourceEnum -> FPML

    set request -> Attributes -> DeliveryType:
        if useCase = AnnaDsbUseCaseEnum -> NDF or useCase = AnnaDsbUseCaseEnum -> NDO
        then empty
        else if Qualify_ForeignExchange_NDS(economicTerms)
        then AnnaDsbDeliveryTypeEnum -> CASH
        else if Qualify_ForeignExchange_Swap(economicTerms)
        then AnnaDsbDeliveryTypeEnum -> PHYS
        else if (settlementTerms -> settlementType = SettlementTypeEnum -> Cash)
        then AnnaDsbDeliveryTypeEnum -> CASH
        else if (settlementTerms -> settlementType = SettlementTypeEnum -> CashOrPhysical)
        then AnnaDsbDeliveryTypeEnum -> OPTL
        else if (settlementTerms -> settlementType = SettlementTypeEnum -> Physical)
        then AnnaDsbDeliveryTypeEnum -> PHYS
        else if (settlementTerms -> settlementType = SettlementTypeEnum -> Election)
        then AnnaDsbDeliveryTypeEnum -> OPTL
        else if (settlementTerms -> physicalSettlementTerms is absent and settlementTerms -> cashSettlementTerms exists)
        then AnnaDsbDeliveryTypeEnum -> CASH
        else if (settlementTerms -> physicalSettlementTerms exists and settlementTerms -> cashSettlementTerms exists)
        then AnnaDsbDeliveryTypeEnum -> OPTL
        else if (settlementTerms -> physicalSettlementTerms exists and settlementTerms -> cashSettlementTerms is absent)
        then AnnaDsbDeliveryTypeEnum -> PHYS
        else if instrumentType = AnnaDsbInstrumentTypeEnum -> Option
                or instrumentType = AnnaDsbInstrumentTypeEnum -> Forward
        then AnnaDsbDeliveryTypeEnum -> PHYS
        else if Qualify_BaseProduct_IRSwap(economicTerms)
                or Qualify_BaseProduct_CrossCurrency(economicTerms)
                or Qualify_BaseProduct_Inflation(economicTerms)
        then AnnaDsbDeliveryTypeEnum -> PHYS
        else if Qualify_AssetClass_Credit(economicTerms)
        then AnnaDsbDeliveryTypeEnum -> OPTL
        else AnnaDsbDeliveryTypeEnum -> CASH // In-case CDM does not have the settlement type information, we default to CASH
    set request -> Attributes -> SettlementCurrency:
        if Qualify_AssetClass_InterestRate(economicTerms)
                or Qualify_AssetClass_Credit(economicTerms)
                or Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
                or Qualify_Commodity_Option(economicTerms)
                or Qualify_ForeignExchange_Spot_Forward(economicTerms)
                or useCase = AnnaDsbUseCaseEnum -> Vanilla_Option
                or useCase = AnnaDsbUseCaseEnum -> Forward
                or useCase = AnnaDsbUseCaseEnum -> FX_Swap
        then empty
        else SettlementTermsLeg1(product)
            then extract
                if settlementType = SettlementTypeEnum -> Cash
                        or cashSettlementTerms exists
                            and (Qualify_BaseProduct_CrossCurrency(economicTerms) = False)
                then ConvertCurrency(settlementCurrency)
                else if useCase = AnnaDsbUseCaseEnum -> Digital_Option
                        or useCase = AnnaDsbUseCaseEnum -> Barrier_Option
                then (economicTerms -> payout -> optionPayout -> exerciseTerms -> strike -> strikePrice -> unit -> currency first then ConvertCurrency)

    set request -> Attributes -> PlaceofSettlement:
        SettlementTermsLeg1(product)
            extract
                if isdaTaxonomy = "ForeignExchange:ComplexExotic"
                            and IsFXForward(product)
                            and settlementType = SettlementTypeEnum -> Cash
                        or settlementTerms -> cashSettlementTerms exists
                            and settlementTerms -> settlementCurrency = "CNH"
                then AnnaDsbPlaceofSettlementEnum -> Hong_Kong

    set request -> Attributes -> ValuationMethodorTrigger:
        if useCase = AnnaDsbUseCaseEnum -> Digital_Option
                or isdaTaxonomy = "ForeignExchange:ComplexExotic"
        then AnnaDsbValuationMethodorTriggerEnum -> Digital_Binary
        else if useCase = AnnaDsbUseCaseEnum -> Swaption
                or useCase = AnnaDsbUseCaseEnum -> Single_Name_Swaption
                or useCase = AnnaDsbUseCaseEnum -> Index_Swaption
                or useCase = AnnaDsbUseCaseEnum -> NDO
                or useCase = AnnaDsbUseCaseEnum -> Debt_Option
                or Qualify_Commodity_Option(economicTerms)
        then AnnaDsbValuationMethodorTriggerEnum -> Vanilla

    set request -> Attributes -> ReferenceRateTermValue:
        if useCase = AnnaDsbUseCaseEnum -> Cross_Currency_Fixed_Fixed
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
                or useCase = AnnaDsbUseCaseEnum -> Total_Return_Swap
                or useCase = AnnaDsbUseCaseEnum -> Fixed_Fixed
                or Qualify_InterestRate_CapFloor(economicTerms)
        then empty
        else if Qualify_InterestRate_Fra(economicTerms)
                or useCase = AnnaDsbUseCaseEnum -> Fixed_Float_Zero_Coupon
        then (if InterestRateLeg2(product) -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier exists
            then InterestRateLeg2(product) -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
            else Compute_IndexTermValue(
                    economicTerms -> payout -> interestRatePayout
                        filter rateSpecification -> floatingRate exists
                        then only-element -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate,
                    economicTerms -> payout -> interestRatePayout
                        filter rateSpecification -> floatingRate exists
                        then only-element -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate
                ))
        else if Qualify_BaseProduct_Inflation(economicTerms)
                or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(economicTerms)
        then (
                    Compute_IndexTermValue(economicTerms -> payout -> interestRatePayout
                        filter rateSpecification -> inflationRate exists
                        then first -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate,
                    economicTerms -> payout -> interestRatePayout
                        filter rateSpecification -> inflationRate exists
                        then first -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate
                ))
        else if Qualify_InterestRate_CrossCurrency_Basis(economicTerms)
        then InterestRateLeg1(product) -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
        else if Qualify_InterestRate_CrossCurrency_FixedFloat(economicTerms)
        then (if interestRatePayoutFloatingLeg -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier exists
            then interestRatePayoutFloatingLeg -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
            else if interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> periodMultiplier exists
            then interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> periodMultiplier
            else interestRatePayoutFloatingLeg -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)
        else InterestRateLeg1(product)
            extract
                if Qualify_AssetClass_Credit(economicTerms) = False
                        or Qualify_InterestRate_CapFloor(economicTerms) = False
                            and (rateSpecification -> floatingRate exists
                                or rateSpecification -> inflationRate exists)
                            and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap
                then (if rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier exists
                    then rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
                    else if paymentDates -> paymentFrequency -> periodMultiplier exists
                    then paymentDates -> paymentFrequency -> periodMultiplier
                    else calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier)

    set request -> Attributes -> ReferenceRateTermUnit:
        if useCase = AnnaDsbUseCaseEnum -> Cross_Currency_Fixed_Fixed
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
                or useCase = AnnaDsbUseCaseEnum -> Total_Return_Swap
                or Qualify_InterestRate_CapFloor(economicTerms)
                or Qualify_InterestRate_IRSwap_FixedFixed(economicTerms)
        then empty
        else if Qualify_InterestRate_Fra(economicTerms)
                or useCase = AnnaDsbUseCaseEnum -> Fixed_Float_Zero_Coupon
        then (if InterestRateLeg2(product) -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> period exists
            then TranslatePeriodEnum(
                        InterestRateLeg2(product) -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> period
                    )
            else AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR)
        else if Qualify_BaseProduct_Inflation(economicTerms)
                or Qualify_InterestRate_InflationSwap_Basis_YearOn_Year(economicTerms)
        then (if economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> indexTenor exists
            then (economicTerms -> payout -> interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> indexTenor first then TranslatePeriodEnum(period))
            else AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR)
        else if Qualify_InterestRate_IRSwap_FixedFloat_OIS(economicTerms)
        then (economicTerms -> payout -> interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> indexTenor
            first
            then TranslatePeriodEnum(period))
        else if Qualify_InterestRate_CrossCurrency_Basis(economicTerms)
        then TranslatePeriodEnum(
                    InterestRateLeg1(product) -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> period
                )
        else if Qualify_InterestRate_CrossCurrency_FixedFloat(economicTerms)
        then (if interestRatePayoutFloatingLeg -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> period exists
            then TranslatePeriodEnum(
                        interestRatePayoutFloatingLeg -> rateSpecification -> floatingRate -> rateOption -> indexTenor -> period
                    )
            else if interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> period exists
            then TranslatePeriodExtendedEnum(
                        interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> period
                    )
            else TranslatePeriodExtendedEnum(
                    interestRatePayoutFloatingLeg -> calculationPeriodDates -> calculationPeriodFrequency -> period
                ))
        else InterestRateLeg1(product)
            extract
                if Qualify_AssetClass_Credit(economicTerms) = False
                        or Qualify_InterestRate_CapFloor(economicTerms) = False
                            and (rateSpecification -> floatingRate exists
                                or rateSpecification -> inflationRate exists)
                            and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap
                then (if rateSpecification -> floatingRate -> rateOption -> indexTenor -> period exists
                    then TranslatePeriodEnum(
                                rateSpecification -> floatingRate -> rateOption -> indexTenor -> period
                            )
                    else if paymentDates -> paymentFrequency -> period exists
                    then TranslatePeriodExtendedEnum(
                                paymentDates -> paymentFrequency -> period
                            )
                    else TranslatePeriodExtendedEnum(
                            calculationPeriodDates -> calculationPeriodFrequency -> period
                        ))

    set request -> Attributes -> OtherLegReferenceRateTermValue:
        if useCase = AnnaDsbUseCaseEnum -> Inflation_Swap
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
        then empty
        else InterestRateLeg2(product)
            extract
                if Qualify_SubProduct_Basis(product -> contractualProduct -> economicTerms)
                then (if rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier exists
                    then rateSpecification -> floatingRate -> rateOption -> indexTenor -> periodMultiplier
                    else paymentDates -> paymentFrequency -> periodMultiplier)

    set request -> Attributes -> OtherLegReferenceRateTermUnit:
        if useCase = AnnaDsbUseCaseEnum -> Inflation_Swap
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
        then empty
        else InterestRateLeg2(product)
            extract
                if Qualify_SubProduct_Basis(product -> contractualProduct -> economicTerms)
                then (if rateSpecification -> floatingRate -> rateOption -> indexTenor -> period exists
                    then TranslatePeriodEnum(
                                rateSpecification -> floatingRate -> rateOption -> indexTenor -> period
                            )
                    else if paymentDates -> paymentFrequency -> period exists
                    then (if paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> C
                        then TranslatePeriodExtendedEnum(
                                    calculationPeriodDates -> calculationPeriodFrequency -> period
                                )
                        else TranslatePeriodExtendedEnum(
                                paymentDates -> paymentFrequency -> period
                            )))

    set request -> Attributes -> UnderlyingInstrumentIndexTermValue:
        InterestRateLeg1CapFloor(product)
            extract
                if IsCapFloor(product)
                then (if (economicTerms -> payout -> interestRatePayout
                        filter rateSpecification -> floatingRate exists
                        then first exists)
                    then (
                                Compute_IndexTermValue(economicTerms -> payout -> interestRatePayout
                                    filter rateSpecification -> floatingRate exists
                                    then first -> calculationPeriodDates -> terminationDate -> adjustableDate -> unadjustedDate,
                                economicTerms -> payout -> interestRatePayout
                                    filter rateSpecification -> floatingRate exists
                                    then first -> calculationPeriodDates -> effectiveDate -> adjustableDate -> unadjustedDate
                            ))
                    else paymentDates -> paymentFrequency -> periodMultiplier)

    set request -> Attributes -> UnderlyingInstrumentIndexTermUnit:
        InterestRateLeg1CapFloor(product)
            extract
                if IsCapFloor(product)
                // or IsCreditDefaultSwapIndex(tradeForEvent)
                then (if paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> T
                    then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR
                    else if paymentDates -> paymentFrequency -> period = PeriodExtendedEnum -> C
                    then TranslatePeriodExtendedEnum(
                                calculationPeriodDates -> calculationPeriodFrequency -> period
                            )
                    else TranslatePeriodExtendedEnum(
                            paymentDates -> paymentFrequency -> period
                        ))

    set request -> Attributes -> DebtSeniority:
        if useCase = AnnaDsbUseCaseEnum -> Non_Standard
                or useCase = AnnaDsbUseCaseEnum -> Total_Return_Swap
        then empty
        else if Qualify_CreditDefaultSwap_SingleName(economicTerms)
                or Qualify_CreditDefaultSwap_Loan(economicTerms)
        then DebtSeniority(product, useCase)

    set request -> Attributes -> ContractSpecification:
        if Qualify_CreditDefaultSwap_SingleName(economicTerms)
        then ReplaceAll(isdaTaxonomy, "[^:]+:", "") to-enum AnnaDsbContractSpecificationEnum

    set request -> Attributes -> ReturnorPayoutTrigger:
        if isdaTaxonomy = "ForeignExchange:ComplexExotic" and IsFXForward(product)
        then AnnaDsbReturnorPayoutTriggerEnum -> Forward_price_of_underlying_instrument
        else if useCase = AnnaDsbUseCaseEnum -> Debt
                or Qualify_Commodity_Forward(economicTerms)
        then AnnaDsbReturnorPayoutTriggerEnum -> Forward_price_of_underlying_instrument
        else if useCase = AnnaDsbUseCaseEnum -> Non_Standard
                and (Qualify_CreditDefaultSwap_SingleName(economicTerms)
                    or Qualify_CreditDefaultSwap_Basket(economicTerms)
                    or Qualify_CreditDefaultSwap_Index(economicTerms)
                    or Qualify_CreditDefaultSwap_IndexTranche(economicTerms))
        then AnnaDsbReturnorPayoutTriggerEnum -> Other
        else if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
        then AnnaDsbReturnorPayoutTriggerEnum -> Total_Return

    set request -> Attributes -> UnderlyingAssetType:
        if isdaTaxonomy = "ForeignExchange:ComplexExotic"
        then AnnaDsbUnderlyingAssetTypeEnum -> Spot

    set request -> Attributes -> UnderlyingIssuerType:
        if (Qualify_CreditDefaultSwap_Index(economicTerms)
                    or Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
                    or Qualify_CreditDefaultSwap_Loan(economicTerms))
                and useCase <> AnnaDsbUseCaseEnum -> Total_Return_Swap
                and useCase <> AnnaDsbUseCaseEnum -> Non_Standard
        then AnnaDsbUnderlyingIssuerTypeEnum -> Corporate

    set request -> Attributes -> Underlying:
        if IsCreditDefaultSwap(product)
                and useCase <> AnnaDsbUseCaseEnum -> Single_Name_Swaption
                and useCase <> AnnaDsbUseCaseEnum -> Index_Swaption
        then (if useCase = AnnaDsbUseCaseEnum -> Non_Standard
            then Create_AnnaDsbUpiRequestUnderlyingForCreditNonStandard(product)
            else Create_AnnaDsbUpiRequestUnderlyingForCredit(product, useCase))
        else if useCase = AnnaDsbUseCaseEnum -> Debt
                or useCase = AnnaDsbUseCaseEnum -> Non_Standard
        then Create_AnnaDsbUpiRequestUnderlyingForRate(product, tradeForEvent, useCase)

    set request -> Attributes -> OtherLegUnderlying:
        if useCase = AnnaDsbUseCaseEnum -> Non_Standard
                and Qualify_SubProduct_Basis(economicTerms)
        then Create_AnnaDsbUpiRequestOtherLegUnderlyingForRate(
                    product,
                    tradeForEvent,
                    useCase
                )

    set request -> Attributes -> NotionalSchedule:
        if Qualify_BaseProduct_IRSwap(economicTerms)
                or Qualify_BaseProduct_Inflation(economicTerms)
                or Qualify_InterestRate_CrossCurrency_Basis(economicTerms)
                or Qualify_InterestRate_CrossCurrency_FixedFloat(economicTerms)
                or Qualify_InterestRate_CrossCurrency_FixedFixed(economicTerms)
        then (if leg1 = leg2
            then leg1
            else AnnaDsbNotionalScheduleEnum -> Custom)

    set request -> Attributes -> BaseProduct:
        if Qualify_Commodity_Swap_FixedFloat(economicTerms)
                or Qualify_Commodity_Swap_Basis(economicTerms)
                or Qualify_Commodity_Option(economicTerms)
                or Qualify_Commodity_Forward(economicTerms)
        then Create_AnnaDsbUpiRequestBaseProductForCommodity(product)

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
func DebtSeniority:
    inputs:
        product Product (1..1)
        useCase AnnaDsbUseCaseEnum (0..1)
    output:
        result AnnaDsbDebtSeniorityEnum (0..1)

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias referenceInformation:
        if IsCreditDefaultSwap(product)
        then EconomicTermsForProduct(product) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation
        else if IsCreditSwaption(product)
        then EconomicTermsForProduct(UnderlierForProduct(product)) -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation

    alias debtSeniority:
        if referenceInformation exists
        then referenceInformation -> referenceObligation -> security -> debtType -> debtEconomics -> debtSeniority
        else if IsTotalReturnSwapDebtUnderlier(product)
        then EconomicTermsForProduct(product) -> payout -> performancePayout only-element -> underlier -> security -> debtType -> debtEconomics -> debtSeniority

    set result:
        if debtSeniority any = DebtSeniorityEnum -> Senior
        then AnnaDsbDebtSeniorityEnum -> SNDB
        else if debtSeniority any = DebtSeniorityEnum -> Subordinated
        then AnnaDsbDebtSeniorityEnum -> SBOD
        else if debtSeniority any = DebtSeniorityEnum -> Secured
        then AnnaDsbDebtSeniorityEnum -> MZZD
        // In-case CDM does not have the seniority information, we default to SNDB
        else if useCase = AnnaDsbUseCaseEnum -> Non_Standard
                or useCase = AnnaDsbUseCaseEnum -> Total_Return_Swap
        then AnnaDsbDebtSeniorityEnum -> SNDB
        // In-case CDM does not have the seniority information, we default to SNDB
        else AnnaDsbDebtSeniorityEnum -> SNDB

func Create_AnnaDsbUpiRequestUnderlyingForCredit:
    inputs:
        product Product (1..1)
        useCase AnnaDsbUseCaseEnum (0..1)
    output:
        underlying AnnaDsbUnderlying (1..1)

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias indexName:
        economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName

    set underlying -> UnderlierIDSource:
        if GetCreditUnderlierLEI(economicTerms) exists
        then AnnaDsbUnderlierIDSourceEnum -> LEI
        else if GetCreditUnderlierISIN(economicTerms) exists
        then AnnaDsbUnderlierIDSourceEnum -> ISIN
        else if Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
        then AnnaDsbUnderlierIDSourceEnum -> CRIDX

    set underlying -> UnderlierID:
        if GetCreditUnderlierLEI(economicTerms) exists
        then GetCreditUnderlierLEI(economicTerms)
        else if GetCreditUnderlierISIN(economicTerms) exists
        then GetCreditUnderlierISIN(economicTerms)
        else if Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
        then (if TranslateIndexNameToId(indexName) exists
            then TranslateIndexNameToId(indexName)
            else ReplaceAll(indexName, ".\\d+.*", ""))

    set underlying -> UnderlyingInstrumentIndexTermValue:
        if Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms) // TerminationDate + 3 months - EffectiveDate -> year
        then Compute_IndexTermValue(
                    economicTerms -> terminationDate -> adjustableDate -> unadjustedDate,
                    economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
                )

    set underlying -> UnderlyingInstrumentIndexTermUnit:
        if Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms) // TerminationDate + 3 months - EffectiveDate -> year
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR

    set underlying -> UnderlyingCreditIndexSeries:
        if Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms) // TerminationDate + 3 months - EffectiveDate -> year
        then economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexSeries

    set underlying -> UnderlyingCreditIndexVersion:
        if Qualify_CreditDefaultSwap_Index(economicTerms)
                or Qualify_CreditDefaultSwap_IndexTranche(economicTerms) // TerminationDate + 3 months - EffectiveDate -> year
        then economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexAnnexVersion

    set underlying -> DebtSeniority:
        if useCase = AnnaDsbUseCaseEnum -> Total_Return_Swap
        then DebtSeniority(product, useCase)

func Create_AnnaDsbUpiRequestUnderlyingForCreditNonStandard:
    inputs:
        product Product (1..1)
    output:
        underlying AnnaDsbUnderlying (1..1)

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias indexName:
        economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexName

    set underlying -> UnderlyingAssetType -> SingleName:
        if Qualify_CreditDefaultSwap_SingleName(economicTerms)
                or Qualify_CreditDefaultSwap_Loan(economicTerms)
        then AnnaDsbSingleName {
                UnderlierIDSource: if GetCreditUnderlierLEI(economicTerms) exists
                    then AnnaDsbUnderlierIDSourceEnum -> LEI
                else if GetCreditUnderlierISIN(economicTerms) exists
                then AnnaDsbUnderlierIDSourceEnum -> ISIN,
                UnderlierID: if GetCreditUnderlierLEI(economicTerms) exists
                    then GetCreditUnderlierLEI(economicTerms)
                else if GetCreditUnderlierISIN(economicTerms) exists
                then GetCreditUnderlierISIN(economicTerms),
                DebtSeniority: DebtSeniority(product, AnnaDsbUseCaseEnum -> Non_Standard)
            }

    set underlying -> UnderlyingAssetType -> CDSIndex:
        if Qualify_CreditDefaultSwap_Index(economicTerms)
        then AnnaDsbCDSIndex {
                UnderlierIDSource: AnnaDsbUnderlierIDSourceEnum -> CRIDX,
                UnderlierID: if TranslateIndexNameToId(indexName) exists
                    then TranslateIndexNameToId(indexName)
                else ReplaceAll(indexName, ".\\d+.*", ""),
                UnderlyingInstrumentIndexTermValue: Compute_IndexTermValue(
                        economicTerms -> terminationDate -> adjustableDate -> unadjustedDate,
                        economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
                    ),
                UnderlyingInstrumentIndexTermUnit: AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR,
                UnderlyingCreditIndexSeries: economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexSeries,
                UnderlyingCreditIndexVersion: economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexAnnexVersion
            }

    set underlying -> UnderlyingAssetType -> CDSIndexTranche:
        if Qualify_CreditDefaultSwap_IndexTranche(economicTerms)
        then AnnaDsbCDSIndex {
                UnderlierIDSource: AnnaDsbUnderlierIDSourceEnum -> CRIDX,
                UnderlierID: if TranslateIndexNameToId(indexName) exists
                    then TranslateIndexNameToId(indexName)
                else ReplaceAll(indexName, ".\\d+.*", ""),
                UnderlyingInstrumentIndexTermValue: Compute_IndexTermValue(
                        economicTerms -> terminationDate -> adjustableDate -> unadjustedDate,
                        economicTerms -> effectiveDate -> adjustableDate -> unadjustedDate
                    ),
                UnderlyingInstrumentIndexTermUnit: AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR,
                UnderlyingCreditIndexSeries: economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexSeries,
                UnderlyingCreditIndexVersion: economicTerms -> payout -> creditDefaultPayout -> generalTerms -> indexReferenceInformation -> indexAnnexVersion
            }

func Create_AnnaDsbUpiRequestUnderlyingForRate:
    inputs:
        product Product (1..1)
        trade Trade (1..1)
        useCase AnnaDsbUseCaseEnum (1..1)
    output:
        underlying AnnaDsbUnderlying (1..1)

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias interestRatePayoutFloatingLeg:
        if RateOption(InterestRateLeg1(product)) -> floatingRateIndex exists
                or RateOption(InterestRateLeg1(product)) -> inflationRateIndex exists
        then InterestRateLeg1(product)
        else if RateOption(InterestRateLeg2(product)) -> floatingRateIndex exists
                or RateOption(InterestRateLeg2(product)) -> inflationRateIndex exists
        then InterestRateLeg2(product)

    set underlying -> UnderlierID:
        if useCase = AnnaDsbUseCaseEnum -> Debt
        then (trade -> tradableProduct -> tradeLot -> priceQuantity -> observable -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            then first extract item -> identifier)
        else if RateOption(interestRatePayoutFloatingLeg) -> floatingRateIndex exists
        then RateOption(interestRatePayoutFloatingLeg) -> floatingRateIndex to-string
        else if RateOption(interestRatePayoutFloatingLeg) -> inflationRateIndex exists
        then RateOption(interestRatePayoutFloatingLeg) -> inflationRateIndex to-string

    set underlying -> UnderlierIDSource:
        if useCase = AnnaDsbUseCaseEnum -> Debt
        then AnnaDsbUnderlierIDSourceEnum -> ISIN
        else if RateOption(interestRatePayoutFloatingLeg) exists
        then AnnaDsbUnderlierIDSourceEnum -> FPML

    set underlying -> ReferenceRateTermValue:
        if RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> periodMultiplier exists
        then RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> periodMultiplier
        else if interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> periodMultiplier exists
        then interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> periodMultiplier
        else interestRatePayoutFloatingLeg -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier

    set underlying -> ReferenceRateTermUnit:
        if RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> period exists
        then TranslatePeriodEnum(
                    RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> period
                )
        else if interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> period exists
        then TranslatePeriodExtendedEnum(
                    interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> period
                )
        else TranslatePeriodExtendedEnum(
                interestRatePayoutFloatingLeg -> calculationPeriodDates -> calculationPeriodFrequency -> period
            )

func Create_AnnaDsbUpiRequestOtherLegUnderlyingForRate:
    inputs:
        product Product (1..1)
        trade Trade (1..1)
        useCase AnnaDsbUseCaseEnum (1..1)
    output:
        underlying AnnaDsbOtherLegUnderlying (1..1)

    alias economicTerms: product -> contractualProduct -> economicTerms

    alias interestRatePayoutFloatingLeg:
        if RateOption(InterestRateLeg2(product)) -> floatingRateIndex exists
                or RateOption(InterestRateLeg2(product)) -> inflationRateIndex exists
        then InterestRateLeg2(product)

    set underlying -> OtherLegUnderlierID:
        if RateOption(interestRatePayoutFloatingLeg) -> floatingRateIndex exists
        then RateOption(interestRatePayoutFloatingLeg) -> floatingRateIndex to-string
        else if RateOption(interestRatePayoutFloatingLeg) -> inflationRateIndex exists
        then RateOption(interestRatePayoutFloatingLeg) -> inflationRateIndex to-string

    set underlying -> OtherLegUnderlierIDSource:
        if RateOption(interestRatePayoutFloatingLeg) exists
        then AnnaDsbOtherLegUnderlierIDSourceEnum -> FPML

    set underlying -> OtherLegReferenceRateTermValue:
        if RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> periodMultiplier exists
        then RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> periodMultiplier
        else if interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> periodMultiplier exists
        then interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> periodMultiplier
        else interestRatePayoutFloatingLeg -> calculationPeriodDates -> calculationPeriodFrequency -> periodMultiplier

    set underlying -> OtherLegReferenceRateTermUnit:
        if RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> period exists
        then TranslatePeriodEnum(
                    RateOption(interestRatePayoutFloatingLeg) -> indexTenor -> period
                )
        else if interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> period exists
        then TranslatePeriodExtendedEnum(
                    interestRatePayoutFloatingLeg -> paymentDates -> paymentFrequency -> period
                )
        else TranslatePeriodExtendedEnum(
                interestRatePayoutFloatingLeg -> calculationPeriodDates -> calculationPeriodFrequency -> period
            )

func Create_AnnaDsbUpiRequestBaseProductForCommodity:
    inputs:
        product Product (1..1)
    output:
        out AnnaDsbBaseProduct (1..1)

    alias economicTerms: product -> contractualProduct -> economicTerms

    // "BaseProduct":{"AGRI":{"GROS":{"AdditionalSubProduct":"FWHT"}
    alias esmaTaxonomy:
        product -> contractualProduct -> productTaxonomy
            filter source = TaxonomySourceEnum -> EMIR
            then extract value
            then filter classification exists
            then distinct only-element

    alias baseProduct: GetClassificationValueByOrdinal(esmaTaxonomy, 1)
    alias subProduct: GetClassificationValueByOrdinal(esmaTaxonomy, 2)
    alias additionalSubProduct: GetClassificationValueByOrdinal(esmaTaxonomy, 3)

    set out -> NRGY:
        if baseProduct = "NRGY"
        then AnnaDsbNRGY {
                ELEC: if subProduct = "ELEC"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                OILP: if subProduct = "OILP"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                NGAS: if subProduct = "NGAS"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                LGHT: if subProduct = "LGHT" then Create_AnnaDsbEmpty,
                RNNG: if subProduct = "RNNG" then Create_AnnaDsbEmpty,
                DIST: if subProduct = "DIST" then Create_AnnaDsbEmpty,
                COAL: if subProduct = "COAL" then Create_AnnaDsbEmpty,
                INRG: if subProduct = "INRG" then Create_AnnaDsbEmpty,
            }

    set out -> AGRI:
        if baseProduct = "AGRI"
        then AnnaDsbAGRI {
                GRIN: if subProduct = "GRIN"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                OOLI: if subProduct = "OOLI"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                SOFT: if subProduct = "SOFT"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                GROS: if subProduct = "GROS"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                SEAF: if subProduct = "SEAF" then Create_AnnaDsbEmpty,
                DIRY: if subProduct = "DIRY" then Create_AnnaDsbEmpty,
                POTA: if subProduct = "POTA" then Create_AnnaDsbEmpty,
                FRST: if subProduct = "FRST" then Create_AnnaDsbEmpty,
                LSTK: if subProduct = "LSTK" then Create_AnnaDsbEmpty,
            }

    set out -> ENVR:
        if baseProduct = "ENVR"
        then AnnaDsbENVR {
                EMIS: if subProduct = "EMIS"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                CRBR: if subProduct = "CRBR" then Create_AnnaDsbEmpty,
                WTHR: if subProduct = "WTHR" then Create_AnnaDsbEmpty,
            }

    set out -> FRGT:
        if baseProduct = "FRGT"
        then AnnaDsbFRGT {
                WETF: if subProduct = "WETF"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                DRYF: if subProduct = "DRYF"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                CSHP: if subProduct = "CSHP" then Create_AnnaDsbEmpty,
            }

    set out -> FRTL:
        if baseProduct = "FRTL"
        then AnnaDsbFRTL {
                AMMO: if subProduct = "AMMO" then Create_AnnaDsbEmpty,
                SLPH: if subProduct = "SLPH" then Create_AnnaDsbEmpty,
                DAPH: if subProduct = "DAPH" then Create_AnnaDsbEmpty,
                PTSH: if subProduct = "PTSH" then Create_AnnaDsbEmpty,
                UREA: if subProduct = "UREA" then Create_AnnaDsbEmpty,
                UAAN: if subProduct = "UAAN" then Create_AnnaDsbEmpty,
            }

    set out -> INDP:
        if baseProduct = "INDP"
        then AnnaDsbINDP {
                CSTR: if subProduct = "CSTR" then Create_AnnaDsbEmpty,
                MFTG: if subProduct = "MFTG" then Create_AnnaDsbEmpty,
            }

    set out -> METL:
        if baseProduct = "METL"
        then AnnaDsbMETL {
                NPRM: if subProduct = "NPRM"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
                    },
                PRME: if subProduct = "PRME"
                    then AnnaDsbAdditionalSubProduct {
                        AdditionalSubProduct: additionalSubProduct to-enum AnnaDsbAdditionalSubProductEnum
        },}

    set out -> PAPR:
        if baseProduct = "PAPR"
        then AnnaDsbPAPR {
                PULP: if subProduct = "PULP" then Create_AnnaDsbEmpty,
                NSPT: if subProduct = "NSPT" then Create_AnnaDsbEmpty,
                RCVP: if subProduct = "RCVP" then Create_AnnaDsbEmpty,
                CBRD: if subProduct = "CBRD" then Create_AnnaDsbEmpty,
            }

    set out -> POLY:
        if baseProduct = "POLY"
        then AnnaDsbPOLY {
                PLST: if subProduct = "PLST" then Create_AnnaDsbEmpty,
            }

    set out -> OTHC:
        if baseProduct = "OTHC"
        then AnnaDsbOTHC {
                DLVR: if subProduct = "DLVR" then Create_AnnaDsbEmpty,
                NDLV: if subProduct = "NDLV" then Create_AnnaDsbEmpty,
            }

    set out -> OTHR: if baseProduct = "OTHR" then Create_AnnaDsbEmpty

func GetClassificationValueByOrdinal:
    inputs:
        taxonomyValue TaxonomyValue (0..1)
        o int (1..1)
    output:
        classificationValue string (0..1)

    set classificationValue:
        taxonomyValue -> classification
            filter ordinal = o
            then distinct only-element
            then extract value

////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////
// func NotionalCurrencyFromPriceQuantity:
//     inputs:
//         priceQuantity ResolvablePriceQuantity (0..1)
//     output:
//         currency string (0..1)
//     set currency:
//         if priceQuantity -> quantitySchedule exists
//         then priceQuantity -> quantitySchedule -> unit -> currency
//         else if priceQuantity -> quantityReference exists
//         then priceQuantity -> quantityReference -> quantitySchedule -> unit -> currency
func FloatingRateIndex:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        floatingRateIndexName string (0..1)
    alias floatingRateIndex:
        if interestRatePayout -> rateSpecification -> floatingRate exists
        then interestRatePayout -> rateSpecification -> floatingRate -> rateOption -> floatingRateIndex
        else if interestRatePayout -> rateSpecification -> inflationRate exists
        then interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> floatingRateIndex
    set floatingRateIndexName: floatingRateIndex to-string

func InflationRateIndex:
    inputs:
        interestRatePayout InterestRatePayout (1..1)
    output:
        inflationRateIndex InflationRateIndexEnum (0..1)
    set inflationRateIndex:
        if interestRatePayout -> rateSpecification -> inflationRate exists
        then interestRatePayout -> rateSpecification -> inflationRate -> rateOption -> inflationRateIndex

func TranslatePeriodExtendedEnum:
    inputs:
        period PeriodExtendedEnum (0..1)
    output:
        value AnnaDsbUnderlyingInstrumentIndexTermUnitEnum (0..1)

    set value:
        if period = PeriodExtendedEnum -> D
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> DAYS
        else if period = PeriodExtendedEnum -> W
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> WEEK
        else if period = PeriodExtendedEnum -> M
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> MNTH
        else if period = PeriodExtendedEnum -> Y
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR

func TranslatePeriodEnum:
    inputs:
        period PeriodEnum (0..1)
    output:
        value AnnaDsbUnderlyingInstrumentIndexTermUnitEnum (0..1)

    set value:
        if period = PeriodEnum -> D
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> DAYS
        else if period = PeriodEnum -> W
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> WEEK
        else if period = PeriodEnum -> M
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> MNTH
        else if period = PeriodEnum -> Y
        then AnnaDsbUnderlyingInstrumentIndexTermUnitEnum -> YEAR

func TranslateAssetClass:
    inputs:
        assetClass AssetClassEnum (1..1)
    output:
        assetClassString AnnaDsbAssetClassEnum (0..1)
    set assetClassString:
        if assetClass = AssetClassEnum -> InterestRate
        then AnnaDsbAssetClassEnum -> Rates
        else if assetClass = AssetClassEnum -> ForeignExchange
        then AnnaDsbAssetClassEnum -> Foreign_Exchange
        else if assetClass = AssetClassEnum -> Credit
        then AnnaDsbAssetClassEnum -> Credit
        else if assetClass = AssetClassEnum -> Equity
        then AnnaDsbAssetClassEnum -> Equity
        else if assetClass = AssetClassEnum -> Commodity
        then AnnaDsbAssetClassEnum -> Commodities

func TranslateIndexNameToId:
    inputs:
        name string (0..1)
    output:
        enumValue string (0..1)

    set enumValue:
        ReplaceAll(name, " SERIES.*$", "") to-enum AnnaDsbMrktCreditIndexEnum to-string

func Enrich_ReportableEventWithCfiCode:
    inputs:
        reportableEvent ReportableEvent (1..1)
        cfiCode string (0..1)
    output:
        enrichedReportableEvent ReportableEvent (1..1)

    set enrichedReportableEvent: reportableEvent

    set enrichedReportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before -> trade -> tradableProduct -> product -> contractualProduct -> productTaxonomy -> value -> name:
        cfiCode

    set enrichedReportableEvent -> originatingWorkflowStep -> businessEvent -> instruction -> before -> trade -> tradableProduct -> product -> contractualProduct -> productTaxonomy -> source:
        TaxonomySourceEnum -> CFI

func ExistingIsin:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        contrProduct string (0..1)

    set contrProduct:
        (ProductForEvent(reportableEvent) -> contractualProduct -> productIdentifier
            filter source = ProductIdTypeEnum -> ISIN
            )
            then first
            then extract identifier

func GetCreditUnderlierLEI:
    inputs:
        economicTerms EconomicTerms (0..1)
    output:
        result string (0..1)

    set result:
        [
            economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceEntity
                then extract
                    FilterEntityIdByScheme(
                            item,
                            "http://www.fpml.org/coding-scheme/external/iso17442"
                        ),
            economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> referencePool -> referencePoolItem first -> referencePair -> referenceEntity
                then extract
                    FilterEntityIdByScheme(
                            item,
                            "http://www.fpml.org/coding-scheme/external/iso17442"
                        )
        ]
            only-element

func GetCreditUnderlierISIN:
    inputs:
        economicTerms EconomicTerms (0..1)
    output:
        result string (0..1)

    set result:
        [
            economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> security -> productIdentifier
                filter source = ProductIdTypeEnum -> ISIN
                then first extract item -> identifier,
            economicTerms -> payout -> creditDefaultPayout -> generalTerms -> referenceInformation -> referenceObligation -> loan -> productIdentifier
                filter source = ProductIdTypeEnum -> ISIN
                then first extract item -> identifier,
            economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> referencePool -> referencePoolItem first -> referencePair -> referenceObligation -> security -> productIdentifier
                filter source = ProductIdTypeEnum -> ISIN
                then first extract item -> identifier,
            economicTerms -> payout -> creditDefaultPayout -> generalTerms -> basketReferenceInformation -> referencePool -> referencePoolItem first -> referencePair -> referenceObligation -> loan -> productIdentifier
                filter source = ProductIdTypeEnum -> ISIN
                then first extract item -> identifier
        ]
            only-element

func ExtractUpi:
    inputs:
        reportableEvent ReportableEvent (1..1)
    output:
        upi string (0..1)

    alias trade: TradeForEvent(reportableEvent)
    set upi:
        trade
            extract tradableProduct -> product -> contractualProduct -> productIdentifier
            then filter source = ProductIdTypeEnum -> UPI
            then only-element
            then extract identifier

func Compute_NotionalScheduleType:
    inputs:
        values number (0..*)
    output:
        scheduleType AnnaDsbNotionalScheduleEnum (1..1)

    set scheduleType:
        if values is absent
        then AnnaDsbNotionalScheduleEnum -> Constant

func Compute_IndexTermValue:
    [codeImplementation]
    inputs:
        terminationDate date (0..1)
        effectiveDate date (0..1)
    output:
        result int (1..1)

func ConvertCurrency:
    inputs:
        currency string (1..1)
    output:
        result string (1..1)
    set result:
        if currency = "CNH"
        then "CNY"
        else if currency = "COO"
        then "COP"
        else if currency = "GBPpence"
        then "GBP"
        else if currency = "ARO"
        then "ARS"
        else if currency = "AZO"
        then "AZN"
        else if currency = "BRO"
        then "BRL"
        else if currency = "CNO"
        then "CNY"
        else if currency = "IDO"
        then "IDR"
        else if currency = "INO"
        then "INR"
        else if currency = "KRO"
        then "KRW"
        else if currency = "MAO"
        then "MAD"
        else if currency = "MYO"
        then "MYR"
        else if currency = "RUO"
        then "RUB"
        else if currency = "THO"
        then "THB"
        else if currency = "TWO"
        then "TWD"
        else if currency = "VNO"
        then "VND"
        else if currency = "XRH"
        then "XXX"
        else if currency = "AUO"
        then "AUD"
        else if currency = "LKO"
        then "LKR"
        else if currency = "UAO"
        then "UAH"
        else currency

func Create_AnnaDsbEmpty:
    output:
        result AnnaDsbEmpty (1..1)

    set result:
        AnnaDsbEmpty {
            emptyField: ""
        }

func FilterEntityIdByScheme: <"Returns the entity ID based on its scheme">
    [codeImplementation]
    inputs:
        legalEntity LegalEntity (1..1)
        scheme string (1..1)
    output:
        result string (0..1)
